<!DOCTYPE html>
<html>
<head>
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-126824460-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!-- End Google Analytics -->


    

    



    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="googleaf4c29130aaf2b72.html">
    
    
    
    
    <title>Java并发包之ReentrantLock、AbstractQueuedSynchronizer | 仰头45℃爆笑 | 生活不止眼前的苟且，还有读不懂的诗和到不了的远方</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="java">
    <meta name="description" content="ReentrantLock介绍 ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。 与synchronized作用相同（隐式支持重入性） **synchronized实现：**JVM中对对象头的操作。获取自增、释放自减方式实现重入。monitorenter monit">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发包之ReentrantLock、AbstractQueuedSynchronizer">
<meta property="og:url" content="https://whllhw.ml/posts/2019/05/09/Java并发包之ReentrantLock、AbstractQueuedSynchronizer/index.html">
<meta property="og:site_name" content="仰头45℃爆笑">
<meta property="og:description" content="ReentrantLock介绍 ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。 与synchronized作用相同（隐式支持重入性） **synchronized实现：**JVM中对对象头的操作。获取自增、释放自减方式实现重入。monitorenter monit">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://q.whllhw.xyz/wp-content/uploads/2019/04/CLH.png">
<meta property="og:updated_time" content="2019-08-19T11:53:18.646Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发包之ReentrantLock、AbstractQueuedSynchronizer">
<meta name="twitter:description" content="ReentrantLock介绍 ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。 与synchronized作用相同（隐式支持重入性） **synchronized实现：**JVM中对对象头的操作。获取自增、释放自减方式实现重入。monitorenter monit">
<meta name="twitter:image" content="https://q.whllhw.xyz/wp-content/uploads/2019/04/CLH.png">
    
        <link rel="alternate" type="application/atom+xml" title="仰头45℃爆笑" href="/rss2.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">whllhw</h5>
          
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-link"></i>
                About
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/whllhw" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Java并发包之ReentrantLock、AbstractQueuedSynchronizer</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Java并发包之ReentrantLock、AbstractQueuedSynchronizer</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-05-09T02:40:00.000Z" itemprop="datePublished" class="page-time">
  2019-05-09
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    

<article id="post-Java并发包之ReentrantLock、AbstractQueuedSynchronizer"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Java并发包之ReentrantLock、AbstractQueuedSynchronizer</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-05-09 10:40:00" datetime="2019-05-09T02:40:00.000Z"  itemprop="datePublished">2019-05-09</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1>ReentrantLock介绍</h1>
<p>ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。<br>
与<strong>synchronized</strong>作用相同（隐式支持重入性）<br>
**synchronized实现：**JVM中对对象头的操作。获取自增、释放自减方式实现重入。<strong>monitorenter</strong> <strong>monitorexit</strong></p>
<h2 id="重入性实现原理">重入性实现原理</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">    private final Sync sync;</span><br><span class="line">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br></pre></td></tr></table></figure>
<p>可知内部有个Sync对象，继承自AQS。lock方法和unlock方法都是代理的Sync对象。默认构造函数是Sync非公平锁。<strong>要理解可重入锁，则就是理解这几个Sync的实现。</strong></p>
<p>可重入如何解决：</p>
<ol>
<li>在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功</li>
<li>由于锁会被获取n次，那么只有锁在被释放同样的n次之后，该锁才算是完全释放成功</li>
</ol>
<h2 id="sync抽象类">Sync抽象类</h2>
<p>继承AQS，重写了<code>nonfairTryAcquire</code>方法，分析可知其流程很简单，利用<code>state</code>字段记录获取的锁数量。当无锁时直接尝试获取，注意只尝试一次没有<strong>自旋CAS</strong>。当有锁时检查是否当前线程获取的锁，是直接则锁数量+1，没有用到CAS。<br>
获取锁的过程【<code>nonfairTryAcquire</code>】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    //1. 如果该锁未被任何线程占有，该锁能被当前线程获取</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   //2.若被占有，检查占有线程是否是当前线程</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        // 3. 再次获取，计数加一</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>释放也是比较简单，先判断是否是当前获取的锁，再直接锁的数量减少，若减少到0则标记当前获取线程为null。注意只有获取锁的时候才用CAS，其他的情况包括：其他线程获取锁，同一线程获取的情况是单线程直接set即可！<br>
释放锁的过程：【<code>tryRelease</code>】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    //1. 同步状态减1</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        //2. 只有当同步状态为0时，锁成功被释放，返回true</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    // 3. 锁未被完全释放，返回false</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br></pre></td></tr></table></figure>
<p>重入锁的释放必须得等到同步状态为0时锁才算成功释放，否则锁仍未释放。</p>
<h2 id="nonfairsync实现类">NonfairSync实现类</h2>
<p>继承之Sync抽象类，只重写了lock方法和tryAcquire方法。<br>
同理，无锁时尝试获取，有锁时请求获取一把，这里会进入到AQS中，AQS会把当前线程加入同步队列并调用LockSupport.park挂起当前线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">            if (compareAndSetState(0, 1))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            else</span><br><span class="line">                acquire(1);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>释放时则是调用了AQS的<code>release</code>，其又执行了Sync抽象类的<code>tryRelease</code>方法，释放完所有锁时会<code>unpark</code>等待队列第一个线程。</p>
<h2 id="fairsync实现类">FairSync实现类</h2>
<p>唯一的区别就是在尝试获取锁的时候，会判断同步队列当前是否有节点在等待、当前节点是否有前驱节点，若有则表示有线程比当前线程更早地请求获取锁，则拒绝本次获取锁的请求，加入到同步队列，并挂起线程。符合FIFO。</p>
<p>这段代码的逻辑与nonfairTryAcquire基本上一致，唯一的不同在于增加了hasQueuedPredecessors的逻辑判断，方法名就可知道该方法用来<strong>判断当前节点在同步队列中是否有前驱节点</strong>的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁。</p>
<h2 id="公平锁和非公平锁利弊">公平锁和非公平锁利弊</h2>
<ol>
<li>公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，<strong>造成“饥饿”现象</strong>。</li>
<li>公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，<strong>保证了系统更大的吞吐量</strong>。</li>
</ol>
<h1>AbstractQueuedSynchronizer</h1>
<p><strong>AbstractQueuedSynchronizer</strong>是被很多类用于实现同步（CountDownLatch、CycliBarrier、ReentrantLock、ReentrantReadWriteLock），ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。<br>
不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在上层已经帮我们实现好了。</p>
<h2 id="lock接口">Lock接口</h2>
<p>concurrent包的关键接口，提供了和synchronized相同的功能，不过要显式加解锁，但需要在finally块内保证解锁。</p>
<h1>AQS（AbstractQueuedSynchronizer）同步器</h1>
<p>用于构建锁和同步器的框架，很多juc中都用其来构建同步器。（ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask）</p>
<h2 id="核心思想">核心思想</h2>
<p><img src="https://q.whllhw.xyz/wp-content/uploads/2019/04/CLH.png" alt=""><br>
底层：CAS，在C++内使用汇编CPU指令</p>
<h2 id="设计模式：模板方法">设计模式：模板方法</h2>
<p>一些方法开放给子类进行重写，而同步器给同步组件所提供模板方法又会重新调用被子类所重写的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    //  throw new UnsupportedOperationException(); // 父类实现</span><br><span class="line">    return nonfairTryAcquire(acquires); // NonfairSync子类实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AQS中的模板方法<code>acquire</code>又调用到了子类重写的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ol>
<li>同步组件（这里不仅仅是可重入锁，还包括CountDownLatch等）的实现依赖于同步器AQS，在同步组件实现中，使用AQS的方式被推荐定义继承AQS的静态内存类；</li>
<li>AQS采用模板方法进行设计，AQS的protected修饰的方法需要由继承AQS的子类进行重写实现，当调用AQS的子类的方法时就会调用被重写的方法；</li>
<li>AQS负责同步状态的管理，线程的排队，等待和唤醒这些底层操作，而Lock等同步组件主要专注于实现同步语义；</li>
<li>在重写AQS的方式时，使用AQS提供的<code>getState()</code>,<code>setState()</code>,<code>compareAndSetState()</code>方法进行修改同步状态</li>
</ol>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-08-19T11:53:18.646Z" itemprop="dateUpdated">2019-08-19 19:53:18</time>
</span><br>


        
        <a href="/posts/2019/05/09/Java并发包之ReentrantLock、AbstractQueuedSynchronizer/" target="_blank" rel="external">https://whllhw.ml/posts/2019/05/09/Java并发包之ReentrantLock、AbstractQueuedSynchronizer/</a>
        
    </div>
    
    <footer>
        <a href="https://whllhw.ml">
            <img src="/img/avatar.png" alt="whllhw">
            whllhw
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>


            


        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/posts/2019/05/09/Java并发之线程池/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Java并发之线程池</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/posts/2019/04/15/Java并发知识整理/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Java并发知识整理</h4>
      </a>
    </div>
  
</nav>



    

















<section class="comments" id="comments">
    <div id="gitalk-container"></div>
    <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"> -->
    <!-- <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script> -->
    <link rel="stylesheet" href="/css/gitalk.css">
    <script src="/js/gitalk.min.js"></script>
    <script>
        var id = location.pathname
        if (location.pathname.length > 50) {
          id = location.pathname.replace(/\/\d+\/\d+\/\d+\//, '').replace('/', '').substring(0, 50)
        }
        const gitalk = new Gitalk({
          clientID: 'dev',
          clientSecret: 'dev',
          repo: 'test_repo',
          owner: 'whllhw',
          admin: ['whllhw'],
          id: id,      // Ensure uniqueness and length less than 50
          title: document.title.split('|')[0],
          distractionFreeMode: false  // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    </script>
</section>




</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/rss2.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可。</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>whllhw &copy; 2016 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <script src="/js/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: false, REWARD: false };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
