<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>仰头45℃爆笑</title>
  
  <subtitle>生活不止眼前的苟且，还有读不懂的诗和到不了的远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://whllhw.xyz/"/>
  <updated>2019-04-16T13:09:54.771Z</updated>
  <id>https://whllhw.xyz/</id>
  
  <author>
    <name>whllhw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发知识整理</title>
    <link href="https://whllhw.xyz/posts/2019/04/15/Java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://whllhw.xyz/posts/2019/04/15/Java并发知识整理/</id>
    <published>2019-04-14T16:13:22.000Z</published>
    <updated>2019-04-16T13:09:54.771Z</updated>
    
    <content type="html"><![CDATA[<h1>笔试题</h1><h2 id="线程间协作方式：-wait-notify-notifyall">线程间协作方式： wait notify notifyAll</h2><p>都是__Object类的final native方法__</p><ol><li>调用wait()能阻塞当前线程，必须拥有当前对象的monitor</li><li>notify()能唤醒一个正等待对象的monitor的线程</li><li>notifyAll()能唤醒等待monitor的线程</li></ol><p>由1可知，调用wait()方法必须在同步块、方法中调用。<br>调用wait()后则交出当前对象的monitor，进入等待状态，（注意与Thread.sleep的区别）<br>使用notify()唤醒任意一个等待该monitor的线程，也必须在同步块中使用。<br>唤醒后不会立即获得monitor，等待退出synchronized块，释放对象锁后才能得到锁执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;笔试题&lt;/h1&gt;
&lt;h2 id=&quot;线程间协作方式：-wait-notify-notifyall&quot;&gt;线程间协作方式： wait notify notifyAll&lt;/h2&gt;
&lt;p&gt;都是__Object类的final native方法__&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用wait
      
    
    </summary>
    
    
      <category term="java" scheme="https://whllhw.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java集合知识整理</title>
    <link href="https://whllhw.xyz/posts/2019/04/15/Java%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://whllhw.xyz/posts/2019/04/15/Java集合知识整理/</id>
    <published>2019-04-14T16:11:06.000Z</published>
    <updated>2019-04-16T13:09:54.760Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库知识整理</title>
    <link href="https://whllhw.xyz/posts/2019/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://whllhw.xyz/posts/2019/04/15/数据库知识整理/</id>
    <published>2019-04-14T16:09:05.000Z</published>
    <updated>2019-04-16T13:09:54.746Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM知识整理</title>
    <link href="https://whllhw.xyz/posts/2019/04/15/JVM%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://whllhw.xyz/posts/2019/04/15/JVM知识整理/</id>
    <published>2019-04-14T16:06:52.000Z</published>
    <updated>2019-04-16T13:09:54.540Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>与计网的那篇一样，整理我看过的JVM知识。我刷完了B站的视频，配合《深入理解Java虚拟机》使用。最有意思是书中的实战部分，内存结构的时候，触发不同内存区域的OOM！没系统整理时，别问，一问就GG。哈哈，每天尽力更新整理，攒面试人品了！</p><h1>思维导图</h1><p><img src="/images/file_1555342244000.png" alt=""><br>内容太多了，先不展开导图</p><h1>Java内存区域</h1><h2 id="导图">导图</h2><p><img src="/images/file_1555344369000.png" alt=""></p><h3 id="内存三大块：">内存三大块：</h3><h4 id="1-堆">1. 堆</h4><p>分为年轻代（Eden、From Survivor、To Survivor，大小比例8:1:1）、老年代。<br>分区原因具体涉及到__GC__</p><h5 id="存放内容">存放内容</h5><p>对象实例<br>数组</p><h5 id="转化过程：">转化过程：</h5><p>新对象在eden区分配（内存不够会在老年代分配），一次GC存活则进入s0、s1中，存活15代进入老年代</p><h5 id="异常抛出">异常抛出</h5><p>OOM</p><h4 id="2-方法区-non-heap">2. 方法区（Non-heap）</h4><p>又称永久代</p><h5 id="存放内容-v2">存放内容:</h5><p>类信息<br>常量<br>静态变量<br>JIT编译代码<br>PS：JDK8移除了方法区，把这些数据放到了直接内存的元数据区<br>常量池信息，存放编译器生成的字面量和符号引用，JDK7移动到堆上存储</p><h5 id="异常抛出：">异常抛出：</h5><p>OOM</p><h4 id="3-栈">3. 栈</h4><p>分为虚拟机栈、本地方法栈。<br>64位长度long和double占用两个局部变量空间（Slot）其他的占用1个</p><h5 id="存放内容-v3">存放内容</h5><ol><li>局部变量表（编译期完成，对应基本数据类型、对象引用）</li><li>操作数栈（字节码相关）</li><li>动态链接</li><li>方法出口</li><li>常量引用</li><li>小对象（无逃逸时，自动回收）</li></ol><h5 id="异常">异常</h5><p>OOM（无法动态扩展时）<br>SOF（大于允许深度时）</p><h4 id="4-程序计数器">4. 程序计数器</h4><p>存放当前线程字节码指令地址，无OOM抛出</p><h4 id="5-直接内存">5. 直接内存</h4><h5 id="1-nio">1. NIO</h5><p>基于通道（channel）和缓存区（buffer）<br>直接使用Native函数分配堆外内存（__DirectByteBuffer__对象引用这块内存）</p><ol><li>避免Java堆、Native堆来回复制数据</li><li>不受Java堆限制（但受本机总内存限制）</li></ol><h3 id="垃圾回收">垃圾回收</h3><p><img src="/images/file_1555416270000.png" alt=""></p><h4 id="算法分类">算法分类</h4><ol><li><p>引用计数法<br>原理：维护对象的引用计数，为0时回收<br>问题：</p><ol><li>性能开销</li><li>循环引用问题</li></ol></li><li><p>标记-清除法<br>原理：从根节点出发，标记所有可达对象，把不可达对象删除</p></li><li><p>标记-压缩法<br>原理：与标记-清除法相同，增加了移动到一侧，清空边界以外的点。以消除碎片</p></li><li><p>复制算法<br><img src="/images/file_1555415892000.png" alt=""><br>原理：两块相同大小的空间，每次把存活对象放到另一块，清空本块。并把大对象放到老年代。<br>问题：</p><ol><li>浪费一半空间</li><li>不适合存活过多的内存区域（老年代）</li></ol></li></ol><h4 id="分代思想">分代思想</h4><p>少量对象，适合复制算法<br>大量存活，适合标记清理、压缩</p><h4 id="一些概念">一些概念</h4><ol><li>什么是可触及性？<br>以下是可触及的：<ol><li>栈中的引用对象</li><li>方法区的静态成员</li><li>常量的引用</li><li>JNI方法栈中的引用对象</li></ol></li><li>什么时候可复活？<br>finalize()中复活对象（当然只会复活一次）</li><li>为什么避免使用finalize？<ol><li>无法确定GC的时间</li><li>为什么不使用更确定性的try catch finally呢？</li></ol></li><li>什么是Stop-The-World现象？<br>多半是由GC引起的出现全局暂停的现象，（其他原因：Dump线程，死锁检查，堆Dump）</li><li>Stop-The-World有什么危害？<ol><li>Java长时间无响应（老年代满出现这种情况）</li><li>考虑有集群的时候，会误判宕机，而出现主备切换（扯远了）</li></ol></li></ol><h4 id="术语">术语</h4><table><thead><tr><th>name</th><th>别名</th><th>含义</th></tr></thead><tbody><tr><td>FUll GC</td><td>Major GC</td><td>清理整个堆</td></tr><tr><td>Old GC</td><td></td><td>清理老年代内存</td></tr><tr><td>Mxinor GC</td><td>Young GC</td><td>清理年轻代内存</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;与计网的那篇一样，整理我看过的JVM知识。我刷完了B站的视频，配合《深入理解Java虚拟机》使用。最有意思是书中的实战部分，内存结构的时候，触发不同内存区域的OOM！没系统整理时，别问，一问就GG。哈哈，每天尽力更新整理，攒面试人品了！&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="java" scheme="https://whllhw.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络知识整理</title>
    <link href="https://whllhw.xyz/posts/2019/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://whllhw.xyz/posts/2019/04/14/计算机网络知识整理/</id>
    <published>2019-04-14T15:14:34.000Z</published>
    <updated>2019-04-16T13:09:54.523Z</updated>
    
    <content type="html"><![CDATA[<h1>计算机网络面试题</h1><h2 id="前言">前言</h2><p>3月份面头条、腾讯被问到很多的计网题。但是自己未学过，也只是在网上看些博客。不得不说博客质量真是参差不齐，甚至某博客平台文章一键转载，可以说是知识污染。朋友推荐看《计算机网络教程：自顶而下方法》也刷得懵懂，又去B站找了考研视频刷了几天，加上自己看视频、看书做的笔记，才对计网有了了解，区分了以前不懂、模糊的概念。这里做整理，为自己攒人品！</p><h2 id="思维导图">思维导图</h2><p><img src="/images/file_1555251089000.png" alt="思维导图"></p><h2 id="协议分层">协议分层</h2><p><img src="/images/file_1555257223000.png" alt="OSI参考模型，来源计算机网络教程：自顶而下方法"></p><h2 id="应用层">应用层</h2><h3 id="http协议">HTTP协议</h3><p>这里东西比较杂，就挑我面试的问题进行整理了</p><h4 id="http1-0-1-1中的区别">HTTP1.0、1.1中的区别</h4><h4 id="websocket-握手">WebSocket 握手</h4><h3 id="dns解析过程">DNS解析过程</h3><h4 id="dns服务器分类">DNS服务器分类</h4><ol><li>根DNS服务器：13台，分布在全球</li><li>顶级服务器：com org edu</li><li>权威服务器：提供域名管理服务，维护域名解析记录</li></ol><h4 id="查询过程">查询过程</h4><p><img src="/images/file_1555256606000.png" alt="查询过程"></p><p><img src="/images/file_1555256700000.png" alt="来源见水印"></p><h4 id="权威性">权威性</h4><ol><li>权威DNS：由域名解析商建设。在域名注册商设置的DNS服务器，对特定域名本身的管理（增、删、改）维护域名解析记录</li><li>非权威DNS：缓存DNS记录，缓存命中直接返回IP，未命中则逐级递归查询，由网络运营商建设，提供域名查询解析服务。</li></ol><h2 id="传输层">传输层</h2><h3 id="多路复用与多路分解">多路复用与多路分解</h3><ul><li>多路复用：应用层所有的应用进程都可以通过传输层再传输给网络层</li><li>多路分解：传输层从网络层接收到数据后交付给指定应用进程</li><li>TCP套接字:四元组（源IP，源端口，目的IP，目的端口）</li><li>UDP套接字:二元组（目的IP，目的端口）</li></ul><ol><li>服务器提供并行TCP套接字有限，原因：<strong>四元组资源耗尽</strong></li><li>多个报文段到达主机后，使用元组定向到不同的套接字</li></ol><h3 id="tcp">TCP</h3><h4 id="1-特点">1.特点</h4><h4 id="2-首部">2.首部</h4><h4 id="3-状态转换图">3.状态转换图</h4><p><img src="/images/file_1555253635000.png" alt="状态转换图"></p><h4 id="4-连接与断开">4.连接与断开</h4><h4 id="5-流量控制">5.流量控制</h4><h4 id="6-拥塞控制">6.拥塞控制</h4><h4 id="7-差错控制-可靠传输">7.差错控制、可靠传输</h4><h3 id="udp">UDP</h3><h4 id="1-特点-v2">1.特点</h4><h4 id="2-首部-v2">2.首部</h4><h4 id="3-与tcp区别-及应用场景">3.与TCP区别，及应用场景</h4><h2 id="网络层">网络层</h2><h2 id="数据链路层">数据链路层</h2><h2 id="物理层">物理层</h2><h2 id="一些面试题">一些面试题</h2><ol><li>TCP三次握手，四次挥手？详细流程（包括每个状态）为什么需要三次握手？为什么需要四次挥手？为什么TIME_WAIT要等待2MSL？</li><li>OSI七层模型与TCP/IP四层模型，各层的作用？</li><li>DNS域名系统</li><li>ARP地址解析协议</li><li>TCP与UDP的区别、使用场景</li><li>滑动窗口协议</li><li>TCP的拥塞控制</li><li>CDN内容分发网络</li><li>Session是什么？什么作用？特点？</li><li>HTTP1.1 新特性</li><li>HTTP状态码，12345各代表什么含义，重要的一些状态码要记住</li><li>HTTP请求报文、响应报文格式</li><li>HTTP八种请求方法</li><li>HTTP与HTTPS</li></ol><h2 id="参考资料">参考资料</h2><ol><li><a href="https://book.douban.com/subject/21267825/" title=" 《计算机网络自顶而下》" target="_blank" rel="noopener">计算机网络教程：自顶而下方法</a></li><li><a href="https://www.bilibili.com/video/av33595294" title="全网最全王道计算机网络 计算机网络王道讲书学习视频" target="_blank" rel="noopener">[全网最全王道计算机网络]计算机网络王道讲书学习视频</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;计算机网络面试题&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;3月份面头条、腾讯被问到很多的计网题。但是自己未学过，也只是在网上看些博客。不得不说博客质量真是参差不齐，甚至某博客平台文章一键转载，可以说是知识污染。朋友推荐看《计算机网络教程：自顶而下方法》也刷
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Servlet学习总结</title>
    <link href="https://whllhw.xyz/posts/2019/04/01/Servlet%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://whllhw.xyz/posts/2019/04/01/Servlet学习总结/</id>
    <published>2019-03-31T16:17:30.000Z</published>
    <updated>2019-04-16T13:09:54.502Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>Spring Boot 中的spring-boot-web-starter中默认配置的Web容器就是Tomcat，而Tomcat是实现了Servlet规范的Web容器，以前在项目中经常用到，但是由于Spring Boot的约定先于配置大大隐藏了Tomcat的复杂性，还有Servlet的一些底层实现，导致在项目用到一些Servlet的东西却不知道其接口之间的关系。加上最近找实习也遇到面试官问这些问题，之前零散在网上看的不系统，回答的时候有点懵，于是花了一天去较为系统的了解这个Java Web中的重要接口。</p><h1>思维导图</h1><p>先看看我导图，然后再自底向上一一道来，归纳得不全，只有常见的接口，接口的实现也没有时间细看。<br><img src="https://upload-images.jianshu.io/upload_images/10215367-a441953f2f80b8b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Servlet"></p><h1>什么是Servlet？</h1><p>Servlet（server applet）是JavaEE（位于javax.servlet）中的编程规范，用在浏览器与Java之间访问交互，只需要实现了Servlet就可以在任意符合其规范的Web容器应用服务器（Tomcat JBoss Wildfly）中运行你的后端代码。从而实现了一次编写到处部署（面向接口编程的好处）！</p><h1>Servlet有哪些常见的接口？</h1><h2 id="servlet接口">Servlet接口</h2><p>留给程序员去实现的一个重要接口，编写业务逻辑，SQL查询之类的</p><ol><li><strong>void init(ServletConfig config)</strong></li></ol><ul><li>servlet 初始化方法，在用户访问时会实例化，该方法会被首次调用，可用于资源连接、打log</li></ul><ol start="2"><li><strong>void destory()</strong></li></ol><ul><li>对象被销毁时调用，放一些资源关闭的一些代码</li></ul><ol start="3"><li><strong>void service(ServletRequest req,ServletResponse res)</strong></li></ol><ul><li>最重要的一个方法，当请求到来的时候会实例出Request Response并调用该方法，常常在这里实现业务逻辑了</li></ul><h2 id="servletconfig接口">ServletConfig接口</h2><p>用于初始化Servlet对象时使用，已由Tomcat实现。</p><ol><li>读取web.xml中的配置信息__init-param__表示，可以用于配置数据库连接等信息。<br>2 . 获取ServletContext</li></ol><h2 id="servletcontext接口">ServletContext接口</h2><p>一个完整的webapp的应用上下文，已由Tomcat实现。<br>启动时创建，服务关闭时被摧毁。可存放__context-param__环境变量、运行时全局共享的一些数据。</p><h2 id="httpservlet抽象类">HttpServlet抽象类</h2><p>继承自GenericServlet（implements Servlet）的抽象类，提供了一些通用的实现：</p><ol><li>ServletConfig在init时保存为引用</li><li>在service实现HTTP请求方式的解析和分发调用算法</li><li><strong>doGet</strong>、__doPost__等方法默认抛出405错误（不支持的请求方式）</li><li>实现HTTP请求头的缓存信息解析</li><li>强制把ServletRequest转换成HttpServletRequest调用service方法</li></ol><h2 id="httpservletrequest接口">HttpServletRequest接口</h2><p>继承自__ServletRequest__，添加了HTTP协议的接口，在__service__方法中使用。添加了：</p><ol><li>url的参数获取（表单、url）</li><li>获取remoteIp</li><li>获取转发器（res.getRequestDispatcher(&quot;/b&quot;).forward(req,res)）</li><li>重定向(res.sendRedirect）与转发器的区别</li><li>getCookie</li><li>getSession</li></ol><h2 id="httpservletresponse">HttpServletResponse</h2><p>继承自ServletResponse，同样拓展了HTTP相关的东西，如：</p><ol><li>sendError发送HTTP状态码和信息</li><li>getOutPutStream</li><li>addCookie</li></ol><h2 id="httpsession接口">HttpSession接口</h2><p>可用__HttpServletRequest.getSession()__获取当前连接的会话。</p><ol><li>获取sessionId</li><li>获取过期时间</li><li>setAttribute、getAttribute、removeAttribute存放会话数据</li></ol><h2 id="cookie接口">Cookie接口</h2><p>可用__HttpServletRequest.getCookie()__获取当前连接的cookie，__res.addCookie__发送给浏览器cookie</p><ol><li>setPath，以最后的斜杠匹配，默认为当前uri发送（/a/b/c匹配/a/b/）</li><li>setMaxAge，过期时间（=0直接删除，&lt;0不存储，&gt;0x秒失效）</li></ol><h1>运行时接口对应关系</h1><ol><li>一个Servlet对象对应一个Config，在web.xml定义的每个servlet的配置</li><li>一个webapp对应ServletContext，所有servlet共享同一个，在web.xml配置整个webapp的配置</li><li>一个请求对应HttpServletRequest，HttpServletResponse，每次请求创建不同的对象</li><li>一个会话对应一个HttpSession，可包含用户的多个请求</li></ol><h1>各接口的生命周期？</h1><h2 id="servlet-httpservlet">Servlet/HttpServlet</h2><ol><li>启动时默认不会被实例化（除非配置load-up-startup）</li><li>用户访问地址</li><li>Web容器解析出对应uri，在容器上下文寻找对应的servlet</li><li>找到则调用其service方法</li><li>没找到则通过web.xml文件的配置获取完整类型，通过反射实例化</li><li>实例化时会执行无参构造方法</li><li>传入ServletConfig到init方法</li><li>最后调用service方法</li><li>销毁：web容器关闭、webapp重新部署、长时间无访问时，则调用destroy()做销毁前的准备</li></ol><h2 id="servletcontext">ServletContext</h2><p>解析web.xml时创建，服务启动时被创建，关闭时销毁。</p><h2 id="httpservletrequest-httpservletresponse">HttpServletRequest HttpServletResponse</h2><p>一次请求对应一个对象，完成请求则销毁</p><h1>我该选择哪个Servlet类去实现？</h1><p>HttpServlet。Servlet接口定义了基本方法，GenericServlet是实现了部分方法的抽象类，查看源码可知：</p><ol><li>实现init(ServletConfig config)，保存了config的引用，并设计一个空的init()供重写</li><li>实现service(ServletRequest request,ServletResponse response)，提供service(HttpServletRequest request, HttpServletResponse response)供重写，避免每次进行转型调用</li></ol><p>HttpServlet是继承GenericServlet的抽象方法，提供了HTTP的更多实现，包括</p><ol><li>在service方法中解析HTTP请求方式，分发GET到doGet，分发POST到doPost。</li><li>提供doXX的默认实现，发送405/400的错误，表示不支持的请求方式。子类需要重写这些方法去支持（巧妙！）</li><li>doGet方法调用前，进行了缓存检查，当未过期时返回304 not modify 表示资源未更改</li></ol><h1>Servlet GenericServlet HttpServlet  体现了什么设计模式？有什么好处？</h1><p>模板方法。HttpServlet是一个模板类，实现了核心算法骨架，doGet doPost 具体实现步骤要在子类中完成。</p><p>特点：doXX，doYY</p><p>作用：</p><ul><li>核心算法保护</li><li>核心算法复用</li><li>不改变算法前提下重新定义算法步骤的具体实现</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;Spring Boot 中的spring-boot-web-starter中默认配置的Web容器就是Tomcat，而Tomcat是实现了Servlet规范的Web容器，以前在项目中经常用到，但是由于Spring Boot的约定先于配置大大隐藏了Tom
      
    
    </summary>
    
    
      <category term="java" scheme="https://whllhw.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>DonkeyCar总结</title>
    <link href="https://whllhw.xyz/posts/2019/01/14/DonkeyCar%E6%80%BB%E7%BB%93/"/>
    <id>https://whllhw.xyz/posts/2019/01/14/DonkeyCar总结/</id>
    <published>2019-01-13T16:24:51.000Z</published>
    <updated>2019-04-16T13:09:54.483Z</updated>
    
    <content type="html"><![CDATA[<p>考完试，终于有时间把这个学期初的坑填上了。还有几位朋友专门关注了我想知道最新的进展，很抱歉啊很久没有消息，也没有什么大进展，下面就说说目前做了的事情和效果。<br><img src="https://upload-images.jianshu.io/upload_images/10215367-ae056cd767caa94d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DonkeyCar俯视图"></p><h1>硬件组装</h1><ol><li>由于3D打印比较贵，就让队友做了一个简易的车架，把必要的设备上去了，不够美观，但是够用了。<br><img src="https://upload-images.jianshu.io/upload_images/10215367-c513dfd15e9cdc11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DonkeyCar正视图"></li></ol><h1>场地</h1><p>由于没有比较好的地方，而且学校智能车的赛道这学期还没有开放。按照slack上Donkeycar网友给出的图纸，临时画了些线在纸上，可能是场地的原因，场地小不够开放，导致效果不好。基本都在转圈，不是按线行驶。<br><img src="https://upload-images.jianshu.io/upload_images/10215367-7836cd0a08d75cab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="赛道设计图"></p><p><img src="https://upload-images.jianshu.io/upload_images/10215367-03a09800fe469249.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="场地图"></p><h1>训练过程</h1><p>很难操作，加上WIFI延迟波动，命令不能及时调整，导致一开始基本无法获得正确的数据。后来用网线直接连接勉强解决，（这个机器学习真费人力）<br>近一万张图片，在没有GPU加速的电脑上训练很慢，用了一个多小时。而在GPU的电脑上用十多分钟就解决了。</p><h1>最终效果</h1><ol><li>油门没有输出，找不出原因，只有角度的输出。最后调成只有角度，手动控制油门。</li><li>在转弯的地方一直在转圈，不会左转出弯，应该是场地左边黑色的边界给识别进去了，加大了权重，到左转时不足？这里我还有视频，但是好像上传有点麻烦，等我处理后再上传。</li><li>训练用的一个方向，但是测试另一个方向时则完全没有效果，估计也是上一个原因吧。</li><li>树莓派只能利用CPU来计算，测试的时候CPU占用有75%，就是3个核已经占满了，性能不是很好。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;考完试，终于有时间把这个学期初的坑填上了。还有几位朋友专门关注了我想知道最新的进展，很抱歉啊很久没有消息，也没有什么大进展，下面就说说目前做了的事情和效果。&lt;br&gt;
&lt;img src=&quot;https://upload-images.jianshu.io/upload_imag
      
    
    </summary>
    
    
      <category term="树莓派" scheme="https://whllhw.xyz/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>树莓派构建wheels下载</title>
    <link href="https://whllhw.xyz/posts/2018/12/28/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9E%84%E5%BB%BAwheels%E4%B8%8B%E8%BD%BD/"/>
    <id>https://whllhw.xyz/posts/2018/12/28/树莓派构建wheels下载/</id>
    <published>2018-12-28T15:25:57.000Z</published>
    <updated>2019-04-16T13:09:54.469Z</updated>
    
    <content type="html"><![CDATA[<p>树莓派是arm平台，用pip安装时，默认从源码构建，编译耗时过长，甚至编译失败<br><a href="http://www.piwheels.org" target="_blank" rel="noopener">www.piwheels.org</a> 提供树莓派预编译二进制包<br>操作步骤：</p><ol><li>在 /etc/pip.conf 添加如下内容，启用源</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">extra-index-url=https://www.piwheels.org/simple</span><br></pre></td></tr></table></figure><p>不过由于镜像在国外，国内有时访问过慢，下载失败。<br>解决：<br>上网站去手动下载 whl 文件到电脑后传给树莓派后执行 pip install $file_name.whl 安装。注意：文件名不能更改，否则会提示：<br>is not a supported wheel on this platform.<br>例如，浏览器给我加的括号1：<br>tensorflow-1.11.0-cp35-none-linux_armv7l (1).whl is not a supported wheel on this platform.</p><p>PS:<br>安装tensorflow时可先安装h5py的whl文件，不然又要编译h5py</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;树莓派是arm平台，用pip安装时，默认从源码构建，编译耗时过长，甚至编译失败&lt;br&gt;
&lt;a href=&quot;http://www.piwheels.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.piwheels.org&lt;/a&gt; 提供树莓派预编
      
    
    </summary>
    
    
      <category term="python, 树莓派" scheme="https://whllhw.xyz/tags/python-%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>读书及写书摘：写下来才是自己的</title>
    <link href="https://whllhw.xyz/posts/2018/12/15/%E8%AF%BB%E4%B9%A6%E5%8F%8A%E5%86%99%E4%B9%A6%E6%91%98%EF%BC%9A%E5%86%99%E4%B8%8B%E6%9D%A5%E6%89%8D%E6%98%AF%E8%87%AA%E5%B7%B1%E7%9A%84/"/>
    <id>https://whllhw.xyz/posts/2018/12/15/读书及写书摘：写下来才是自己的/</id>
    <published>2018-12-15T07:45:10.000Z</published>
    <updated>2019-04-16T13:09:54.454Z</updated>
    
    <content type="html"><![CDATA[<p>开学的时候受公众号（stormzhang）影响在当当买了几本书，大佬推荐的一些理财书（《富爸爸穷爸爸》、《小狗钱钱》），还有一些运营的书（《启示录》、《增长黑客》）。和好友一起凑单买了几本，很快囫囵吞枣把一页页书吃掉，书上知识、理念很开眼界，但是现在博主已经全都忘记书上说过什么了，可能得再次翻开书才能找回看书时熟悉的感觉。今天写这篇水文，就当总结阅读来的感悟，还有不足之处吧。<br>以前的时候基本没怎么看书，天真地利用搜索引擎，以为有了搜索引擎就什么都可以找到。直到发现我遇到的问题开始在网上找不到了，不再是简单的是什么，怎么解决某个错误怎么处理，如何入门XX。可能这就是天花板了，简单的知识网上全都是，但是经过处理消化的知识不会遍地都是。很多“隐藏”内容都在书上写着、在文档里躺着，等着去阅读、去发掘。而且只利用网络上的只言片语、某些知道问答类型的网站，不会建立知识的网络，只是内容的搬运工，没有思考便得到答案，用进废退，早晚变笨蛋。一开始博主就是这么想的，有什么不会直接网上搜，肯定都有的，直接复制下来。经过一年两年发现自己的知识只是停留在片面，别人一说起某个名词，脑子里只知道好像在哪个网上博客里看到过，并不清楚到底是什么。网络真是把双刃剑，多少人没有利用好它，白白浪费自己的生命（当然这也让一些营销号、公司赚到了钱，甚至上了市），本来用来交换信息的好方式，不过这也不能怪工具，还是得从自己出发，发挥主观能性<br>这学年课很水，也不喜欢上课了，上课就打开手机看书或是带本书过去看，如今一学期快考试了，却还啥都不会。</p><ol><li>提醒自己该干嘛<br>比如一开始小狗钱钱里钱钱让（女主什么来着，网上找找）吉娅开始每天写成功笔记，并让读者也天天写自己成功的事情，博主也坚持做了一周时间，都后来就没有再写过了，达不到持久效果，果然人还是有惰性的。</li><li>看了很多书，还是涨点知识<br>今年在微信读书上看了不少的书，有各大厂的传记：</li></ol><ul><li>《顺势而为：雷军传》雷军从武汉电子一条街到做 WPS 、做投资、到现在做价格公道感动人心的小米</li><li>《腾讯传》一开始进这个App直接送的书籍（鹅厂也是够暗示了），不记得具体内容了，就是记录鹅厂的崛起故事，从寻呼机、OICQ，QQ、移动梦网到张小龙的微信<br>一些理财知识书籍，成功学？？：</li><li>《小狗钱钱》以小说情节中穿插金钱、投资的概念和做法</li><li>《富爸爸穷爸爸》直接上干货，对比自己的爸爸和好友的爸爸做法，引出穷人思维和富人思维。</li><li>《牛奶可乐经济学》揭示日常生活的经济学。<br>一些优点技术干货的书籍：</li><li>《蚂蚁金服：科技金融独角兽的崛起》这本还记得比较清楚，一本讲述支付宝是如何从淘宝分出来一个独立的系统，如何称霸的，面对各银行的不理睬，只有一家工商银行杭州支行给了支付接口，支付宝才得以用所谓快捷支付撸走用户银行卡里的钱。到现在做余额宝、基金、保险等互联网金融业务。还是挺振奋人心的，一开始的内部不支持，外部没银行支持，然后这个项目直接完蛋（怎么和阿里云一样了，可能记混了）</li><li>《淘宝技术这十年》外行人看热闹，内行人看门道。面对淘宝这样指数增长的业务流量，说了很多技术方面的事情，从买php源码，从Oracle，到自己开发数据库Oceanbase，开源项目能用到了都针对自己的业务量改过，并发行了自己的分支版本。其中几位码神多隆这样的人才，用神样的操作硬是让某些技术达到传说级别。</li><li>《网络是怎么连接的》《程序是怎样跑起来的》日本人写的一个系列书籍某某是怎样的，比较浅显，不像一些专业书籍那么难理解</li><li>《图解HTTP》也是一些入门书籍</li><li>《白帽子讲Web安全》先讲解了一些安全的基本概念，人是不安全因素。还有XSS、CSRF、SQL注入一些Web漏洞的防护。</li><li>《操作系统之哲学原理》强行哲学，有道理，看完也写不了操作系统<br>还有一些是程序员修养、职业生涯这类的，会写书的程序员谈心路历程之类的。没有做记录，已经不知道说了什么了。</li><li>《MacTalk》</li><li>《程序员的自我修养》</li></ul><p>本来是要摘录《软件随想录》里面的内容，但是写着就变成了这个读书总结了？哈哈哈。进入正题：<br>程序员部落酋长乔尔在给计算机系的学生的建议中有下面几点，本人觉得相见恨晚，没有早点在图书馆发现此书：</p><blockquote><p>给计算机系学生的建议</p><ul><li>毕业前练好写作</li><li>毕业前学好C语言</li><li>毕业前学好微观经济学</li><li>因为枯燥就不选修非计算机专业的课程</li><li>选修有大量编码实践的课程</li><li>担心所有的工作都被印度人抢走</li><li>找一份好的暑期实习工作</li><li>寻求专业人士的帮助，培养你的自信心<br><img src="https://upload-images.jianshu.io/upload_images/10215367-d9889f7784b54551.png" alt=""></li></ul></blockquote><p>虽然书籍写的是十年前的博客摘录，博客上面提到的很多公司没听过，上面的Windows还停留在XP时代，巨硬开发Office，IE，制定一些魔鬼标准，Joel 还谈论他创建的软件，宣传一些开发理念，给开发人员最好的工作环境。现今博客还在更新 <a href="https://www.joelonsoftware.com/" target="_blank" rel="noopener">https://www.joelonsoftware.com/</a><br>就先到这里，写的文字没有逻辑性，还是得多写，不能埋头苦干，别人都不知道你在干什么。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开学的时候受公众号（stormzhang）影响在当当买了几本书，大佬推荐的一些理财书（《富爸爸穷爸爸》、《小狗钱钱》），还有一些运营的书（《启示录》、《增长黑客》）。和好友一起凑单买了几本，很快囫囵吞枣把一页页书吃掉，书上知识、理念很开眼界，但是现在博主已经全都忘记书上说过
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring Boot 中流操作使用</title>
    <link href="https://whllhw.xyz/posts/2018/11/21/Spring%20Boot%20%E4%B8%AD%E6%B5%81%E6%93%8D%E4%BD%9C%E4%BD%BF%E7%94%A8/"/>
    <id>https://whllhw.xyz/posts/2018/11/21/Spring Boot 中流操作使用/</id>
    <published>2018-11-21T07:50:33.000Z</published>
    <updated>2019-04-16T13:09:54.440Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8里面的流对象真好用，函数式编程让编码不一样，并且还能并发执行。这里给出一个业务中实际遇到的数据查询映射成一个奇特的Map映射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  table1: [</span><br><span class="line">    &#123;</span><br><span class="line">      name1: &quot;&quot;,</span><br><span class="line">      name2: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name1: &quot;&quot;,</span><br><span class="line">      name2: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  table2: [</span><br><span class="line">    &#123;</span><br><span class="line">      name3: &quot;1&quot;,</span><br><span class="line">      name4: &quot;2&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name3: &quot;3&quot;,</span><br><span class="line">      name4: &quot;4&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用普通的操作分别查询出table内的数据行得到<code>List&lt;table1Entity&gt; lists</code> 然后<code>Map.put(&quot;table1&quot;,lists)</code>就完成了，但是这对于表多的话重复代码就变多了，不符合代码重用的思想。这里给出一个解决方法：</p><p>使用 Java8 的stream API可以较为高效的并发操作，不过理解起来有点难度，（调试也需要一点技巧？）</p><p>首先新建一个key的列表<code>List&lt;String&gt; names</code>， 由其生成一个stream放入查询接口进行查询，得到另一个流，使用一个map进行映射出Javabean，利用filter删除为空的结果，最后Collectors.toList() 收集流。此时得到的是table1、table2的键值对数组（<code>[{&quot;name1&quot;:&quot;&quot;,&quot;name2&quot;:&quot;&quot;}]</code>)。下面给他们按类别扔进对应的Key（由于没有统一基类故使用反射API调用其类型函数，返回类别），<code>Collectors.toMap(s-&gt;{s.get(0).getClass().getMethod(&quot;getItemType&quot;).invoke(s)},s-&gt;s)</code>。附一张图参考，可能还需要进一步优化，不过肯定比线性查询出来后一行一行来的快（见灰色注释掉的代码）<br><img src="https://upload-images.jianshu.io/upload_images/10215367-99779f446545dd7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流操作消除重复代码"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 8里面的流对象真好用，函数式编程让编码不一样，并且还能并发执行。这里给出一个业务中实际遇到的数据查询映射成一个奇特的Map映射&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
      
    
    </summary>
    
    
      <category term="spring boot, java" scheme="https://whllhw.xyz/tags/spring-boot-java/"/>
    
  </entry>
  
  <entry>
    <title>一个大创项目中期检查说几句</title>
    <link href="https://whllhw.xyz/posts/2018/10/19/%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%88%9B%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%9F%E6%A3%80%E6%9F%A5%E8%AF%B4%E5%87%A0%E5%8F%A5/"/>
    <id>https://whllhw.xyz/posts/2018/10/19/一个大创项目中期检查说几句/</id>
    <published>2018-10-19T09:15:25.000Z</published>
    <updated>2019-04-16T13:09:54.427Z</updated>
    
    <content type="html"><![CDATA[<h1>0</h1><p>暑假项目组一起开发了一个 Spring Boot 项目，内容很多很复杂，代码有好看的也有不好看的，从设计到开发，谁也没有经验（辅导员敢这么相信我们，很感动😂）。没有经过系统测试，草草便上线了，效果还意外不错？！😂</p><h1>1</h1><p>自己是用户才能设计出好产品，知道痛点是什么，而不是设计某某系统，写文档介绍说很牛叉，真正用起来就是另一回事。</p><ul><li>可能开发人员不清楚真正核心的需求是什么，没有考虑用户体验，直接上手堆砌代码，以代码行数取胜。</li><li>过度需求，加上无用的功能，分散用户注意力。不论怎样，加上再说，提需求的人自己搞不清楚到底要什么。</li><li>线下流程过于繁重，想要在线上重现也麻烦。</li></ul><h1>2</h1><p>现在处于摸索阶段，期望不要太高，毕竟不是专业开发。不过能开发出数百人同时使用的网站也感觉很好了，主要是现在工具好用，能力没多高（但是人就是会用工具提升自己的生产力，没有工具就回到原始时代）</p><h1>3</h1><ul><li>除了第二天凌晨被刷网站目录，好像也没遇到什么安全问题。（可能只是没发现）互联网这么开放，安全问题首要考虑啊。</li><li>一个展示的地方设计得不对，用户看不到图片，紧急新写了一个接口展示数据。（设计和开发都有责任）</li><li>辅导员过期后，要求重新审核数据。看了很久代码，才知道改一改数据库就完事了。（可以说是文档不完善）</li></ul><h1>4</h1><p>没收到多少反馈，可能是发了操作指南吧😂（跟学校系统一样需要指南）这也反应出不足吧，不能一眼就知道如何操作？</p><h1>5</h1><p>没有搜集用户数据（也没啥可搜集的），没有搜集业务接口访问量（可能访问量上来才有用吧）</p><hr><h1>附：统计数据</h1><p>目前已上线的综测系统，顺利完成了今年16级信息院综测相关业务。包括学生填报加分项并上传证明图片、班长进行审核该班级的证明、辅导员最终确认有效加分项。下文统计数据时间段为：9月11日 9:00 到 9月16日 0:00<br><img src="https://upload-images.jianshu.io/upload_images/10215367-4554bb1723d93ae4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流量数据"></p><ul><li>前端页面资源使用CDN进行分发，使用回源策略更新文件，减少业务服务器的压力。综测期间使用了8.9GB流量，同时在线达到300 ，资源命中率达90%。实际到达服务器的流量不到500MB，网页加载速度提升，有效提升了用户体验。由于使用的打包工具可计算文件的MD5指纹，在我们更新代码时生成唯一的文件名，避免用户从CDN缓存中获取到旧版本的代码文件。首页入口文件不进行缓存，保证每次访问页面总是询问源服务器是否为最新版本的首页。其他文件缓存30天，代码没有更新时能够快速从本地客户端缓存中获取，同时也减小对CDN的压力和流量。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10215367-c92f01609476421b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片CDN使用流量"></p><ul><li>证明图片使用对象存储和CDN分发，有效保障了此次审核证明业务。综测期间共上传了 2.9GB 的图片资源，图片访问总流量75.26GB，日均流量12.54GB，峰值带宽21.10Mbps，该时间节点为学生停止申报前。图片资源访问次数总量90,611次，日均15,102次。图片资源的存储以及分发，极其占用磁盘空间、网络带宽。若放在业务服务器上必定对其他基础业务有影响，降低了并发数，用户一多就不能正常服务，出现一到高峰就宕机的情况，但是本项目使用使用对象存储服务，CDN进行资源分发。业务服务器在接受到客户端图片资源的请求时，只需要返回一个带授权凭证的URL，客户端便可以向CDN请求数据，流量转移到CDN而不会直接到业务服务器，减少其对其他基础业务的影响。<br>同学们对该系统反应良好，反应其网络响应速度比一般网站都要快速。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;0&lt;/h1&gt;
&lt;p&gt;暑假项目组一起开发了一个 Spring Boot 项目，内容很多很复杂，代码有好看的也有不好看的，从设计到开发，谁也没有经验（辅导员敢这么相信我们，很感动😂）。没有经过系统测试，草草便上线了，效果还意外不错？！😂&lt;/p&gt;
&lt;h1&gt;1&lt;/h1&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="spring boot, java" scheme="https://whllhw.xyz/tags/spring-boot-java/"/>
    
  </entry>
  
  <entry>
    <title>实现一个自己的无人车：Donkey Car 一个小型汽车开源DIY自动驾驶平台</title>
    <link href="https://whllhw.xyz/posts/2018/10/01/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A0%E4%BA%BA%E8%BD%A6%EF%BC%9ADonkey%20Car%20%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9E%8B%E6%B1%BD%E8%BD%A6%E5%BC%80%E6%BA%90DIY%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E5%B9%B3%E5%8F%B0/"/>
    <id>https://whllhw.xyz/posts/2018/10/01/实现一个自己的无人车：Donkey Car 一个小型汽车开源DIY自动驾驶平台/</id>
    <published>2018-10-01T15:27:40.000Z</published>
    <updated>2019-04-16T13:09:54.415Z</updated>
    
    <content type="html"><![CDATA[<h1>self driving car</h1><blockquote><p>An opensource DIY self driving platform for small scale cars.<br>RC CAR     Raspberry Pi   Python (tornado, keras, tensorflow, opencv, …)<br><a href="https://github.com/wroscoe/donkey" target="_blank" rel="noopener">https://github.com/wroscoe/donkey</a></p></blockquote><h2 id="donkeycar-a-python-self-driving-library">donkeycar: a python self driving library</h2><blockquote><p>Donkeycar is minimalist and modular self driving library for Python. It is developed for hobbyists and students with a focus on allowing fast experimentation and easy community contributions.<br><a href="http://www.donkeycar.com/" target="_blank" rel="noopener">http://www.donkeycar.com/</a></p></blockquote><ul><li>基于python的极简、模块化的自动驾驶库</li><li>开源社区驱动项目</li></ul><h1>设计理念</h1><ul><li>快速</li><li>模块化</li><li>可扩展</li><li>Keep It Simple, Stupid (KISS)</li></ul><blockquote><p>把复杂的事情变简单，这是一件复杂的事情</p></blockquote><hr><h1>使用的技术</h1><p><img src="https://upload-images.jianshu.io/upload_images/10215367-fbb3d9300bc8e034.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Keras"></p><h2 id="keras-：基于-python-的深度学习库">Keras ：基于 Python 的深度学习库</h2><p><a href="https://github.com/keras-team/keras" target="_blank" rel="noopener">https://github.com/keras-team/keras</a></p><ul><li>Deep Learning for humans</li><li>可以以TensorFlow, CNTK, 或者Theano 作为后端运行</li><li>支持快速实验，最小时延<ul><li>允许简单而快速的原型设计（由于用户友好，高度模块化，可扩展性）</li><li>支持卷积神经网络和循环神经网络，以及两者的组合。</li><li>在 CPU 和 GPU 上无缝运行。</li></ul></li><li>开源</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10215367-cbe7c807e33baa5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Tornado"></p><h2 id="tornado">Tornado</h2><p><a href="https://github.com/tornadoweb/tornado" target="_blank" rel="noopener">https://github.com/tornadoweb/tornado</a></p><ul><li>高性能 web 框架和异步网络库（非阻塞网络 I/O）</li><li>开源<br><img src="https://upload-images.jianshu.io/upload_images/10215367-8dbfc84bb25a5571.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TensorFlow"></li></ul><h2 id="tensorflow：深度学习工具">Tensorflow：深度学习工具</h2><p><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">https://github.com/tensorflow/tensorflow</a></p><ul><li>Tensor 张量即N维数组，Flow 流即基于数据流图的计算，合起来即张量从图一端到另一端</li><li>Google 开源</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/10215367-aa483965b7eef4d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OpenCV"></p><h2 id="opencv：机器视觉库">Opencv：机器视觉库</h2><p><a href="https://github.com/opencv/opencv" target="_blank" rel="noopener">https://github.com/opencv/opencv</a></p><ul><li>实时图像处理、计算机视觉以及模式识别</li><li>Intel 开源</li></ul><hr><h1>硬件 DIY</h1><p><img src="https://upload-images.jianshu.io/upload_images/10215367-eeec2fe5cec50593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Raspberry Pi 俯视图"><br><img src="https://upload-images.jianshu.io/upload_images/10215367-c4c316ce3b5da690.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Raspberry Pi 外设连接图"></p><h2 id="树莓派">树莓派</h2><blockquote><p>The Raspberry Pi Foundation is a UK-based charity that works to put the power of digital making into the hands of people all over the world, so they are capable of understanding and shaping our increasingly digital world, able to solve the problems that matter to them, and equipped for the jobs of the future.</p></blockquote><ul><li>为学生计算机编程教育设计的卡片式电脑</li><li>开源硬件、软件</li><li>ARM Debian8.0 系统，定制硬件驱动与软件程序</li></ul><h2 id="普通遥控车改装">普通遥控车改装</h2><p><img src="https://upload-images.jianshu.io/upload_images/10215367-7956d228b60ac326.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="大脚车示例"></p><ol><li>电机速度控制器<ul><li>PWM控制</li></ul></li><li>转向伺服系统<br><img src="https://upload-images.jianshu.io/upload_images/10215367-f2ceb349e5c87806.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9g 舵机"><ul><li>PWM控制</li></ul></li><li>有刷电机驱动</li><li>传感器<br><img src="https://upload-images.jianshu.io/upload_images/10215367-dce242dcf9382bb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="广角相机"><ul><li>广角相机</li></ul></li></ol><h2 id="最终效果图">最终效果图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10215367-585943f27acaec24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="donkey car"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;self driving car&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;An opensource DIY self driving platform for small scale cars.&lt;br&gt;
RC CAR     Raspberry Pi   Python
      
    
    </summary>
    
    
      <category term="树莓派" scheme="https://whllhw.xyz/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>连接到极品飞车世界 CN 服务器</title>
    <link href="https://whllhw.xyz/posts/2018/09/16/%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%9E%81%E5%93%81%E9%A3%9E%E8%BD%A6%E4%B8%96%E7%95%8C%20CN%20%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://whllhw.xyz/posts/2018/09/16/连接到极品飞车世界 CN 服务器/</id>
    <published>2018-09-16T12:57:59.000Z</published>
    <updated>2019-04-16T13:09:54.403Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章主要讲如何连接服务器。关于如何自己搭建服务器看我的博客<a href="">这篇文章</a>或者 <a href="https://www.jianshu.com/p/c0c64200b45e" target="_blank" rel="noopener">简书</a></p></blockquote><hr><p>提供一个我最近搭建的服务器，连接方法在下面。<br><strong>地址：<a href="http://q.whllhw.xyz:1337" target="_blank" rel="noopener">http://q.whllhw.xyz:1337</a></strong></p><hr><h1>前言</h1><p>看到了敖厂长出的视频，居然还有这样的游戏能开私服。目前网上能搜到的就这篇文章<a href="https://www.bilibili.com/read/cv44595/" target="_blank" rel="noopener">【极品飞车世界】私服连接教程</a><br>游戏画面当然不能跟现在的游戏比较，硬核玩家才不会在意这些。<a href="https://www.bilibili.com/video/av25753282" target="_blank" rel="noopener">【敖厂长】死掉的极品飞车游戏</a><br><img src="https://upload-images.jianshu.io/upload_images/10215367-761f611236891f57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="当然是去卡收费站的bug啦"></p><p>不过连接国外的服务器有问题，ping 值 200 ，还登录不了。最近 zesty 开的CN 服务器也莫名其妙不见了，可能是关掉了吧。😂<br><img src="https://upload-images.jianshu.io/upload_images/10215367-9c729948532d0050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SoapboxRaceWorld.world也打不开"><br>我于是就花了一个星期去找资料（其中用到 docker 也算是学习的过程）现在基本搭建好了，而且还对 soapbox world 的启动器进行了适配（强行适配）<br>在搭建的文章中我写了如何搭建服务器，由于缺少支持，soapbox world 官方文档简陋，缺少数据表，无法用其提供的软件进行搭建。我找到了 <a href="https://github.com/michelinus" target="_blank" rel="noopener">michelinus</a>/<strong><a href="https://github.com/michelinus/nfsw-server" target="_blank" rel="noopener">nfsw-server</a></strong> 使用 maven 进行构建，打包出一个 jar 包，部署简单多了。</p><h1>正文</h1><ol><li>去到上面提到的 <a href="https://www.bilibili.com/read/cv44595/" target="_blank" rel="noopener">bilibili 网页</a>，打开网盘下载<br><img src="https://upload-images.jianshu.io/upload_images/10215367-9a4358b854bc4781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开网盘"><br><img src="https://upload-images.jianshu.io/upload_images/10215367-be6fe23c02fb72dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选中这两项，一个是游戏本体，一个是启动器。下载即可"></li><li>下载完了，解压出来，分别我这里解压到了两个文件夹<br><img src="https://upload-images.jianshu.io/upload_images/10215367-d009079df1ea9bec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>打开启动器（可能会提示更新，先更新即可）稍等界面出来，这时应该会自动开始下载游戏文件没关系，右上角有设置按钮点进去，选择游戏文件路径（有 nfsw.exe 的文件夹）其他的选项跟我一样即可，点击 SAVE 会提示重启启动器。<br><img src="https://upload-images.jianshu.io/upload_images/10215367-1f024db83338d5f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择刚才解压的文件夹，注意要有 nfsw.exe 的文件夹"></li><li>重启完了之后，如果游戏路径选择正确就出现 DOWNLOAD COMPLETED.否则还会自动下载游戏文件<br><img src="https://upload-images.jianshu.io/upload_images/10215367-4d58061050fc59a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="成功后的就不会再下载文件了"></li></ol><p>5.添加服务器（点右上角的加号）输入名称（随意输入），输入服务器地址：<a href="http://q.whllhw.xyz:1337" target="_blank" rel="noopener">http://q.whllhw.xyz:1337</a> 选择OK，提示已经添加成功<br><img src="https://upload-images.jianshu.io/upload_images/10215367-28b52f49fa9823eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>6.添加完了之后要自行重启启动器，然后在服务器列表就能看到了，选中刚才添加的一项<br><img src="https://upload-images.jianshu.io/upload_images/10215367-ba868a04d7ec206c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol start="7"><li>最后，点击绿色按钮注册一个账号，注册完了就能登录了 PLAY NOW ！</li><li>enjoy！</li></ol><hr><p>Ps：若出现无法添加服务器，检查输入是否有问题（建议服务器地址从上面复制进去），也可能服务器正在维护，可以在下面留言询问。其他任何问题也可以给我留言。<br><img src="https://upload-images.jianshu.io/upload_images/10215367-caca1e59a342e925.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加服务器时出现Please check better..."></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇文章主要讲如何连接服务器。关于如何自己搭建服务器看我的博客&lt;a href=&quot;&quot;&gt;这篇文章&lt;/a&gt;或者 &lt;a href=&quot;https://www.jianshu.com/p/c0c64200b45e&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
    
      <category term="游戏服务器" scheme="https://whllhw.xyz/tags/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>极品飞车世界 NFS World 服务器搭建教程</title>
    <link href="https://whllhw.xyz/posts/2018/09/16/%E6%9E%81%E5%93%81%E9%A3%9E%E8%BD%A6%E4%B8%96%E7%95%8C%20NFS%20World%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <id>https://whllhw.xyz/posts/2018/09/16/极品飞车世界 NFS World 服务器搭建教程/</id>
    <published>2018-09-16T11:36:14.000Z</published>
    <updated>2019-04-16T13:09:54.390Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章主要讲搭建过程，以及出现问题的解决方法。难度较高，我已经搭建好了服务器供玩耍，如何连接服务器看<a href="">这篇文章</a>或者 <a href="https://www.jianshu.com/p/23bcb1dcbe26" target="_blank" rel="noopener">简书</a></p></blockquote><h1>不推荐的方法</h1><p>我先找到 github <a href="https://github.com/SoapboxRaceWorld/soapbox-race-core" target="_blank" rel="noopener">SoapboxRaceWorld</a>上面的开源服务器，尝试了很久，最后搭建好了之后发现游戏中购车的界面进不去，在后台数据库发现少数据，但是我已经全部导入了的😂<br><img src="https://upload-images.jianshu.io/upload_images/10215367-481f81f16c4de4f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缺少表"><br><img src="https://upload-images.jianshu.io/upload_images/10215367-af34e1c7d352abb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在代码里面搜索，能在代码里找到，给的SQL文件里面没有。"></p><p>既然已经不推荐用这种方法了，可以跳过这里。</p><p><img src="https://upload-images.jianshu.io/upload_images/10215367-a65815bd7e0c07d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="已经一年没更新了"><br>打包出来的是 war ，需要 wildfly 才能部署，需要做的事情如下：</p><ol><li>下载 releases 打包好的 war，以及 wiki 里提供的 <a href="https://github.com/SoapboxRaceWorld/soapbox-race-core/wiki/Wildfly" target="_blank" rel="noopener">wildfly</a> （google drive 要梯子）</li><li>放入 war 到 wildfly 目录下的 standalone/deployments<br><img src="https://upload-images.jianshu.io/upload_images/10215367-27c7690cb692e51f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="war 包放入这个文件夹"></li><li>配置 openfire 服务 （配置文件 wildfly/standalone/configuration/standalone.xml）<br>配置 xmppIp 为公网地址（必须检查）<br>Udp freeroam、race 都是未完成的功能（私服官方到现在都没搞定😂我也不知道是什么功能）<br>配置 openfire restful api 地址<br>配置 openfire token<br><img src="https://upload-images.jianshu.io/upload_images/10215367-2dd9d478730bda3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="standalone.xml 中系统属性示例"><br>也可以登录wildfly 后台修改http://localhost:9990/console/App.html#profile/properties（需要创建账户，运行 <a href="http://add-user.sh" target="_blank" rel="noopener">add-user.sh</a> 按提示即可）。<br><img src="https://upload-images.jianshu.io/upload_images/10215367-417366ed002f7a25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统属性配置"></li><li>配置数据库，同样可以编辑 xml 也可以登录后台数据源配置<br><img src="https://upload-images.jianshu.io/upload_images/10215367-99b3df61bcaa0f57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="默认用户密码 soapbox soapbox"><br>5.（可选）配置绑定的后台管理地址<br><img src="https://upload-images.jianshu.io/upload_images/10215367-43948106498e3815.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="默认绑定127.0.0.1，docker镜像我改成0.0.0.0了"></li><li>可在后台重启服务<br><img src="https://upload-images.jianshu.io/upload_images/10215367-e71f34fa506ec8af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重新加载服务"></li></ol><hr><h1>正文</h1><p>wiki 给出需要用到服务 openfire 、mysql 、wildfly（后面我找到了 nfsw-server.jar替换掉）都需要用到数据库，所以先从数据库开始吧。<br><img src="https://upload-images.jianshu.io/upload_images/10215367-2a7052fc6c9f35db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="来源 https://github.com/SoapboxRaceWorld/soapbox-race-core/wiki/How-does-it-work?"></p><h2 id="搭建前提">搭建前提</h2><p>有 1G 以上的内存，公网IP（如果只是要本地，直接下一个模拟器就好了，不用这么麻烦。），最好 Linux 主机，windows 没试过，不过应该也行。</p><h2 id="1-mysql-数据库">1. MySQL 数据库</h2><ol><li>导入<a href="https://github.com/whllhw/nfsw-server/blob/master/db/OPENFIRE.sql" target="_blank" rel="noopener">OPENFIRE.sql</a>，<a href="https://github.com/whllhw/nfsw-server/blob/master/db/soapbox.sql" target="_blank" rel="noopener">soapbox.sql</a>（修改后从数据库导出的，原来的 db.sql 有点问题，soapbox 数据库大小写没对上😂）<br>默认openfire用户名：openfire 密码 openfire<br>默认soapbox用户名：soapbox 密码soapbox<br>PS：不用来试我数据库了，没开放3306端口，我是用SSH通道用密钥连接的。</li><li>保持数据运行就好了</li></ol><h2 id="2-openfire-配置">2.openfire 配置</h2><p>如 wiki 写的一样<a href="https://github.com/SoapboxRaceWorld/soapbox-race-core/wiki/OpenFire" target="_blank" rel="noopener">OpenFire</a>从 google drive下载。<br><img src="https://upload-images.jianshu.io/upload_images/10215367-19953b811b7fd089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.配置数据库连接"><br>登录后台，admin 密码 admin<br>访问 localhost:9090/plugins/restapi/rest-api.jsp 启用 restful api 把 openfire token 保存下来配置nfsw-server需要用到<br>登录后台 localhost:9090/server-properties.jsp<br>Xmpp.domain 改为与后面的nfsw-server.cfg中xmppIp一样的地址<br><img src="https://upload-images.jianshu.io/upload_images/10215367-cf73df842d711753.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.配置Xmpp.domain 一般为内网 ip （使用外网ip的话云服务一般都要去配置安全组，openfire 只要能访问就行了）"><br><img src="https://upload-images.jianshu.io/upload_images/10215367-52e422b7c147aca1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置Xmpp.domain错误导致连接的时候会检验 Host 字段，不相同则无法建立连接，无法使用聊天服务"><br>运行 <code>openfire/bin/openfire start</code>让其在后台运行即可。<br>日志文件在 <code>openfire/logs/</code>目录下，有问题时可以使用<code>tailf openfire/logs/all.log</code>持续查看输出，方便找配置错误，当没有报数据库连不上，没有打印出一些堆栈时就可配置nfsw-server了，否则检查配置是否有误。</p><h2 id="3-nfsw-server-配置">3.nfsw-server 配置</h2><p><a href="https://github.com/whllhw/nfsw-server/releases" target="_blank" rel="noopener">在github下载nfsw-server.jar、nfsw-server.cfg</a>也可以自己编译，下载 jdk、maven执行 <code>mvn clean compile assembly:single</code></p><ol start="0"><li><p>配置数据库连接（src/main/resources/META-INF/persistence.xml）使用打包的话可以先替换掉压缩包里的 xml<br><img src="https://upload-images.jianshu.io/upload_images/10215367-ebd0debfd07f5f2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="如果不改用户名密码的话配置好url即可，或者添加 host 解析nfsw-server 到ip地址127.0.0.1 也可以"></p></li><li><p>在nfsw-server.cfg中配置xmppIp（在openfire配置的xmpp.domain 一定要一样，否则报错 <code>Unable to authenticate: Fail to create new session.</code>）</p></li><li><p>openfireToken（在openfire配置的openfireToken）</p></li><li><p>httpPort是游戏开放端口，我用的是1337（外网开放1337端口）<br><img src="https://upload-images.jianshu.io/upload_images/10215367-476964e1a7c54e06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="其他没提到的就和上图一样就好了"></p></li><li><p>nfsw-server.cfg，nfsw-server.jar 放在同一目录下执行<code>java -jar nfsw-server.jar</code><br>注意看输出，先连接 openfire restful api 返回 201说明 openfire 连接成功<br><img src="https://upload-images.jianshu.io/upload_images/10215367-73ba3c1133550a6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="201才表示连接成功"><br>然后连接数据库，当没有报数据库连不上，没有打印出一些堆栈时就可应该可以了，否则检查配置是否有误。</p></li></ol><h1>enjoy！</h1><p>nfsw 服务搭建已经完成，在开头的文章下载 nfsw 以及启动器就可以登录了！等会再写一篇客户端登录的教程<br>PS：我准备把这个服务做成 docker 镜像，这样部署的时候就不用这么配来配去（自己捣鼓了差不多一个星期才搞定，先是 wildfly 搭建的数据库缺数据，无法购买车辆，后是 openfire 中 xmpp.domain 配置错误，进入游戏就提示与服务器断开连接，其实是跨域的问题，nfsw-server的xmppIp要与其相同。）<br>上面项目都是基本已经停止维护的，使用的 openfire 是4.0.2 的，我fork的老哥<a href="https://github.com/michelinus" target="_blank" rel="noopener">michelinus</a>/**<a href="https://github.com/michelinus/nfsw-server" target="_blank" rel="noopener">nfsw-server</a>**也停止更新一年了。<br>有问题可以在下面留言哦，欢迎一起交流（虽然极大可能零回复）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇文章主要讲搭建过程，以及出现问题的解决方法。难度较高，我已经搭建好了服务器供玩耍，如何连接服务器看&lt;a href=&quot;&quot;&gt;这篇文章&lt;/a&gt;或者 &lt;a href=&quot;https://www.jianshu.com/p/23bcb1dcbe26&quot; ta
      
    
    </summary>
    
    
      <category term="java" scheme="https://whllhw.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Visual Studio 2017 无法登陆提示脚本错误</title>
    <link href="https://whllhw.xyz/posts/2018/09/10/Visual%20Studio%202017%20%E6%97%A0%E6%B3%95%E7%99%BB%E9%99%86%E6%8F%90%E7%A4%BA%E8%84%9A%E6%9C%AC%E9%94%99%E8%AF%AF/"/>
    <id>https://whllhw.xyz/posts/2018/09/10/Visual Studio 2017 无法登陆提示脚本错误/</id>
    <published>2018-09-10T02:17:26.000Z</published>
    <updated>2019-04-16T13:09:54.373Z</updated>
    
    <content type="html"><![CDATA[<p>打开 VS 发现许可证过期，需要登陆后重新获取，但是登陆时提示：<a href="https://auth.gfx.ms/16.000.27887.2/OldConvergedLogin_PCore.js" target="_blank" rel="noopener">https://auth.gfx.ms/16.000.27887.2/OldConvergedLogin_PCore.js</a> Script error 无法执行脚本。<br>浏览器打开发现脚本没问题。重启多试几次，还是不行，就直接搜这个网址，还真有：<a href="https://www.cnblogs.com/xxyxxb2080/p/9520837.html" target="_blank" rel="noopener">VS2017登陆不了,TFS无法连接成功的问题</a><br>果然，我的 win7 是 ie8，不过都是用 chrome 上网的（巨硬都是用系统自带的东西，也是服了），马上更新<br><a href="https://www.microsoft.com/en-us/download/internet-explorer-11-for-windows-7-details.aspx" target="_blank" rel="noopener">ie 11 更新包</a><br><img src="/images/ie1.png" alt="下载运行提示缺少必要的更新，弹出网页，下载所有安装即可，再重启电脑安装ie 11"><br><img src="/images/ie2.png" alt="安装 ie 11"><br>更新完了之后，我发现 Office 也能登录了，可以愉快的用 OneNote 了。😄</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打开 VS 发现许可证过期，需要登陆后重新获取，但是登陆时提示：&lt;a href=&quot;https://auth.gfx.ms/16.000.27887.2/OldConvergedLogin_PCore.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ht
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>暑假有感</title>
    <link href="https://whllhw.xyz/posts/2018/09/03/%E6%9A%91%E5%81%87%E6%9C%89%E6%84%9F/"/>
    <id>https://whllhw.xyz/posts/2018/09/03/暑假有感/</id>
    <published>2018-09-02T16:03:06.000Z</published>
    <updated>2019-04-16T13:09:54.360Z</updated>
    
    <content type="html"><![CDATA[<p>以前回家总是没事情做，天天无所事事，每次放假回来都充满内疚感，什么都没有做，高三老师曾说，假期是超越别人的最好时期。那这样说来，我都不知道被超越了多少了。但是这个假期，可以说是有收获的。时间匆匆，近两个月的时间很快就结束了，时间总是过得很快，让人来不及记得发生过的事。这段时间，是很开心的，可以说是令人激动的。认识这么多优秀的同学，还有老司机学长。每次交流总能有新的笑点，分享经验，分享遇到各种的坑。我不善于交际、很少交流、表达困难，在外人眼前很少暴露自己狂热的内心想法。但是在这个团队里却觉得很舒适，不会觉得很压抑，也是很感谢各个同学和学长一起营造的友好氛围。</p><p>第一次见面时候，紧张，慌乱，害怕融入不了这个集体，过了一个暑假到现在却不舍离开。早上一过去，盯了一会屏幕，就该吃午饭了，然后又到了晚上了。很快一个暑假就过去了，仿佛就是昨天。</p><p>很多时候，我觉得我都做的不足，其实我是可以解决得更多的事情，可以分担一下队友的锅，或者是重构一些代码，而不是袖手旁观。学习积累不足，很多东西直接就用起来了。有时间还是要多读文档，了解相关知识，不然到时候用起来就容易 GG。</p><ul><li>顺便就加上 CDN ，对象存储等云服务。直接把静态页面放在了七牛上面，但是资源的刷新在更新代码后看不到效果，即便强制刷新也不能出来（在七牛上刷新也无效）。后面还是用 CDN 回源，把前端资源放在腾讯云服务器上。</li><li>在多人协作方面真是要多学习，比如代码合并问题，还有沟通上存在的问题，效率受影响。真实的项目要做好确实不容易，很多东西缺乏统一，缺乏规范，缺乏测试代码，导致后面问题很多。（只能慢慢修补了）</li><li>代码模块之间的耦合度还是比较高，有的地方直接用 repository ，有的地方调用 service</li><li>数据库的建模也需要一定的规划，统一字段名，数据类型，索引建立，唯一性约束，（外键还是有待商榷）</li><li>缺少 DBA ，测试人员，（现在都是人肉测试，出了问题就直接改）不过毕竟也是小型项目，大家都是边学边做，也没有有经验人员指导，只是在网上翻，在一些书里面翻，缺少实践，也就找不到最佳实践。<br>（其他的待更新）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以前回家总是没事情做，天天无所事事，每次放假回来都充满内疚感，什么都没有做，高三老师曾说，假期是超越别人的最好时期。那这样说来，我都不知道被超越了多少了。但是这个假期，可以说是有收获的。时间匆匆，近两个月的时间很快就结束了，时间总是过得很快，让人来不及记得发生过的事。这段时
      
    
    </summary>
    
    
      <category term="java" scheme="https://whllhw.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>idea git push 引起的血案</title>
    <link href="https://whllhw.xyz/posts/2018/08/26/idea%20git%20push%20%E5%BC%95%E8%B5%B7%E7%9A%84%E8%A1%80%E6%A1%88/"/>
    <id>https://whllhw.xyz/posts/2018/08/26/idea git push 引起的血案/</id>
    <published>2018-08-26T14:21:58.000Z</published>
    <updated>2019-04-16T13:09:54.348Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>操作不当导致一天内写的代码丢失，最后依靠 idea 的本地历史（local history）找回。</p></blockquote><p>过程：</p><ol><li>使用 idea 的 VSC 工具进行 git commit （用这个主要是这个带有自动整理代码，优化导入的功能，还会分析代码）</li><li>想了想应该只有我有最新的版本了，别人不会有更新的。于是直接点开 git push （以前都是先使用 git pull 的，这次脑残了）</li><li>提示有冲突，是否进行合并，选择是，自动合并完毕后。编译代码失败。一看，我一天写的写的定时消息通知不见了。</li><li>我的妈啊，怎么直接没了，赶紧打开 bash 用 <code>git reflog</code> 结果如下：（有两处的 commit 信息是 add: 加入各处通知）<br><img src="/images/TIM%E6%88%AA%E5%9B%BE20180828233327.png" alt=""></li><li><code>ee2fa85</code> 直接变成了 merge 节点，而且我的提交直接就没有了，恢复不了。<code>git reset --hard</code> 只能回到原来的版本，但是记录里面根本没有我提交的版本</li><li>救命稻草：idea 本地历史，idea 提供了磁盘上所有文件的修改记录，并且标注了时间，after push 、build 的操作就记录了下来，（这么吃内存也是有好处）于是我凭记忆恢复了我一天写的代码。</li><li>最后再提交、推送到远程库</li></ol><ul><li>从 gitea 上面的提交图来看，也说明了这次血案的原因<br><img src="/images/TIM%E6%88%AA%E5%9B%BE20180828232021.png" alt=""><br>由提交图可以看到，我提交了一个 merge 节点，用于自动合并与其他人的代码版本。这个节点应该是 git 自动生成的，提交信息里面应该有 merge branch 字样，但是这个提交直接用我的 commit 信息了。</li></ul><hr><p>其实还有点疑惑的地方，有时间复现一下，看一看到底是怎么回事。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;操作不当导致一天内写的代码丢失，最后依靠 idea 的本地历史（local history）找回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 idea 的 VSC 工具进行 git commit （用这个主要
      
    
    </summary>
    
    
      <category term="git" scheme="https://whllhw.xyz/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>升级到 spring boot 2.0</title>
    <link href="https://whllhw.xyz/posts/2018/08/25/%E5%8D%87%E7%BA%A7%E5%88%B0%20spring%20boot%202.0/"/>
    <id>https://whllhw.xyz/posts/2018/08/25/升级到 spring boot 2.0/</id>
    <published>2018-08-24T16:48:07.000Z</published>
    <updated>2019-04-16T13:09:54.335Z</updated>
    
    <content type="html"><![CDATA[<p>spring boot 2.0 版本出了有一段时间了，当然是要用一用了，把现在在写的项目升级一波。当然升级前是看了一下别人的博客 <a href="http://tengj.top/2018/07/23/springboot2to1/" target="_blank" rel="noopener">http://tengj.top/2018/07/23/springboot2to1/</a> 。（怎么感觉有质量的博客越来越少，剩下的就是在互相“引用”，搜出来基本一模一样，国内某搜索引擎更加差劲，还是自己抽时间看文档比较好）本篇持续更新（随缘）</p><hr><ul><li>首先在 pom.xml 中修改 1.5.10 为 2.0.4 （项目要求稳定一点，也不能太激进。）</li><li>idea 下载依赖的时候，手动运行 mvn clean 等命令下载依赖，不然会出现 idea 依赖下完，还是不能构建，至今不知道为什么，是什么 bug</li></ul><p>2.0 中的更改：</p><ol><li>删除 repository 的 findOne ，导致以前使用的 findOne 不能使用，直接替换为 getOne 会出现以下问题：<br><img src="/images/gson.png" alt="getOne 返回代理类HibernateProxy，进行序列化时出错，提示添加适配器。"></li></ol><p>简单解决：<br>用 findById 回避代理类，但是这个接口又被改成返回 <code>Optional&lt;S&gt;</code> 必须使用 get() 来获取 实体。Optional 要求内容非空，否则使用 get() 方法会抛出异常 NoSuchElementException ，优雅了解决空指针异常。</p><ol start="2"><li>new PageRequest 不推荐使用 @Depreacted ，直接更换为静态方法  PageRequest.of，点进去看是返回 new PageRequest 。（之前在 1.5 好像就是不推荐用 of 静态方法，现在又改回来了）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;spring boot 2.0 版本出了有一段时间了，当然是要用一用了，把现在在写的项目升级一波。当然升级前是看了一下别人的博客 &lt;a href=&quot;http://tengj.top/2018/07/23/springboot2to1/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="spring boot" scheme="https://whllhw.xyz/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>重装系统后要做的事情</title>
    <link href="https://whllhw.xyz/posts/2018/08/06/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <id>https://whllhw.xyz/posts/2018/08/06/重装系统后要做的事情/</id>
    <published>2018-08-06T01:39:41.000Z</published>
    <updated>2019-04-16T13:09:54.323Z</updated>
    
    <content type="html"><![CDATA[<ul><li>前一阵子参加信息院的安全竞赛，竟然获得了一个固态硬盘。马上装上 win10 体验一波。原来买电脑的时候就是装的 win10，后面各种卡顿（年少无知，非要去电脑城买），直接换成 win7。最近 win7爆出使用数量下降，肯定是电脑更新换代，都是预装 win10。ok，不多说了，进入主题。</li><li>进入 win10 后，要求登录 Microsoft 账号，BABALA填完后，进入等待桌面加载。动画效果确实好，比 win7 更加炫酷。但是开始菜单多了很多用不到的东西和用不了到的东西比如 OneNote、天气、新闻、联系人…所以第一步：卸载这些无用的东西。</li><li>由于我以前将用户数据和系统分离，为了少安装一些常用的软件，通常把用户文档、桌面移动到其他盘，在新系统上设置一下就恢复了快捷访问。</li><li>其他的不多说了，就是安装一些非绿色版，要修改注册表的软件，杀毒软件、 office 等等，调整系统设置<br>（ok，这是一个月之前的事情了，我很多都忘了。win10游戏时输入法无法打字，以及 windows defender 一直偷cpu，一气之下格式化C盘。下面才是我现在在用的重装过后的win7）</li><li><em>详细列一下开发要设置的东西，便于以后查阅</em>：</li></ul><ol><li>安装运行库。这些都没有自带，给差评。visual c   redistributable ，DirectX，.net framework 等等。推荐一个软件<a href="https://www.iplaysoft.com/aio-runtimes.html" target="_blank" rel="noopener">All in One Runtimes</a>可以直接安装以上的运行库。</li><li>可绿色运行的开发软件添加一下系统路径。如  python3 (python2出现并发数设置不对的错误，估计是配置文件放在了系统盘上)，jetbrain（导入以前的设置，还有登录账号激活），nodejs（包括.\node_modules\.bin）</li><li>listary 效率工具设置自启动（有了它桌面都可以不要，只要你知道要用什么软件，直接键入名称即可启动），bandizip 添加文件关联，sublime vscode notepad</li><li>重新安装一下git，虽然可以是绿色版本，但是使用系统自带的cmd真的好丑。使用 git-bash 就好一点了</li><li>复制一下服务器私钥到用户主目录下，这样 ssh 就不用输密码了。</li><li>安装 chrome，有时候 google 打不开，只能去各软件广告商下载。再手动导入科学插件，最后登录账号，基本就结束了。<br>现在做的事情基本就这么多，过几天有新东西再更新。</li></ol><hr><p>更新：</p><ol><li>安装 Office 2016 使用 <a href="https://github.com/officetoolplus/OTool" target="_blank" rel="noopener">https://github.com/officetoolplus/OTool</a> 服务器上安装 docker 版本的 vlmcsd 授权激活，但是在 office 上无法登陆账号，朋友的 Office 2019 可以用。一直没找到原因。</li><li>finallshell 可以加速海外服务器的访问，看了一下 last 命令，是有两个账号同时登陆，查 ip 是阿里云香港，进行了转发，效果好了很多。</li><li>MobaXterm 分屏同时多个终端输入，管理服务器真的不要太爽，比 putty 好用多了。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;前一阵子参加信息院的安全竞赛，竟然获得了一个固态硬盘。马上装上 win10 体验一波。原来买电脑的时候就是装的 win10，后面各种卡顿（年少无知，非要去电脑城买），直接换成 win7。最近 win7爆出使用数量下降，肯定是电脑更新换代，都是预装 win10。o
      
    
    </summary>
    
    
      <category term="电脑" scheme="https://whllhw.xyz/tags/%E7%94%B5%E8%84%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot 笔记</title>
    <link href="https://whllhw.xyz/posts/2018/03/21/Spring%20boot%20%E7%AC%94%E8%AE%B0/"/>
    <id>https://whllhw.xyz/posts/2018/03/21/Spring boot 笔记/</id>
    <published>2018-03-21T14:19:59.000Z</published>
    <updated>2019-04-16T13:09:54.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jpa">JPA</h2><ul><li><p>中文乱码</p><ol><li>检查数据库编码<ul><li><code>show variables like 'character_set_database';</code>–查看该数据库使用的编码</li><li><code>alter database &lt;数据库名&gt; CHARACTER SET utf8;</code>–修改编码为utf8</li><li><code>show create table &lt;表名&gt;;</code>–查询表的编码，默认为：latin1</li><li><code>alter table &lt;表名&gt; character set utf8;</code>–修改表的编码</li></ul></li><li>检查JPA连接配置<ul><li>spring.datasource.url后面加上<code>characterEncoding=utf-8</code>参数</li></ul></li></ol><p><strong>ps：后面才知道mysql的utf8是假的，只支持三字节的编码，utf8mb4才是现在称的真正utf8</strong></p></li></ul><h2 id="view-object">View Object</h2><p>因为前端要的字段可能跟数据库里的不同，或者要其他的数据，都在一个接口处返回，或者嵌套对象返回。<br>解决方法是使用一大片 getter setter for 语句来处理，代码极其不好看。于是花半天时间查阅 <a href="https://docs.spring.io/spring-data/jpa/docs/1.11.13.RELEASE/reference/html/#projections" target="_blank" rel="noopener">jpa</a> 文档，发现可以用到 VO 来解决这些问题。<br>这里直接就贴上代码看一下就ok了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompreGradeItem</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">getCompreRank</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// more...与数据库字段相同的直接写 get 方法</span></span><br><span class="line"><span class="comment">// 使用Value注解，获取到对象内的成员</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;target.student.major&#125;"</span>)</span><br><span class="line">    <span class="function">String <span class="title">getMajor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 新建的键值对，可以利用 spel 实现简单的处理</span></span><br><span class="line"><span class="comment">// 要实现高级自定义，则编写自己的 bean 可以实现任意逻辑（下面一个）</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;@compreGradeBean.getAddGroup(target)&#125;"</span>)</span><br><span class="line">    <span class="function">List&lt;Object&gt; <span class="title">getAddGroup</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompreGradeBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CompreAddGradeRepository compreAddGradeRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AwardBean awardBean;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompreGradeBean</span><span class="params">(CompreAddGradeRepository compreAddGradeRepository, AwardBean awardBean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.compreAddGradeRepository = compreAddGradeRepository;</span><br><span class="line">        <span class="keyword">this</span>.awardBean = awardBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getAddGroup</span><span class="params">(CompreGradeEntity compreGradeEntity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 在这里编写自定义的方法，可以再进行查询。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompreGradeRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">CompreGradeEntity</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Page&lt;CompreGradeItem&gt; <span class="title">findAllByStudentMajorLikeAndStudentStuClassLikeAndYearTerm</span><span class="params">(String major,String stuClass,String yearTerm,Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>更新：<br>用这种方法，由于 jpa 无法预知程序员想要留下的字段，所以直接全部字段都查询出来，数据量少应该无所谓，但是最好还是写 nativeQuery 这样数据库压力会小点，但是返回的是 <code>List&lt;Object[]&gt;</code> 映射字段名就麻烦了。用 setter ？不存在的。尽量避免写出无意义，而且容易出错的代码<br>下面说一下我正在使用的方法：<br>配合 java 8 的特性 stream 实现字段映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要映射的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassForm</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String A;</span><br><span class="line"><span class="keyword">private</span> String B;</span><br><span class="line"><span class="comment">// 这里是一个需要调用 bean 的一个参数</span></span><br><span class="line"><span class="keyword">private</span> String C;</span><br><span class="line"><span class="comment">//   getter   setter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassForm <span class="title">map</span><span class="params">(Object[] i)</span></span>&#123;</span><br><span class="line">ClassForm tmp = <span class="keyword">new</span> ClassForm();</span><br><span class="line">tmp.setA(i[<span class="number">0</span>]);</span><br><span class="line">tmp.setB(i[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模仿流式 api</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassForm <span class="title">setC</span><span class="params">(String c)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.C = c;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在外层调用的时候</span></span><br><span class="line">List&lt;Object[]&gt; x = repository.findAllByXXX(xxx);</span><br><span class="line">List&lt;ClassForm&gt; r = x.stream().map(s-&gt;ClassForm.map(s).setC(myBean.getC(s[<span class="number">2</span>]))).Collect(Collector.toList());</span><br><span class="line"><span class="comment">// 随后 r 就可以通过反射 API，自动生成 JSON 数据了</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jpa&quot;&gt;JPA&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;中文乱码&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查数据库编码
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;show variables like &#39;character_set_database&#39;;&lt;/code&gt;–查看该数据库使用的编码
      
    
    </summary>
    
    
      <category term="spring boot" scheme="https://whllhw.xyz/tags/spring-boot/"/>
    
  </entry>
  
</feed>
