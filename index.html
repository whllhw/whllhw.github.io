<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="生活不止眼前的苟且，还有读不懂的诗和到不了的远方"><meta name="keywords" content=""><meta name="author" content="whllhw"><meta name="copyright" content="whllhw"><title>生活不止眼前的苟且，还有读不懂的诗和到不了的远方 | 仰头45℃爆笑</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-126824460-1', 'auto');
ga('send', 'pageview');</script><meta name="google-site-verification" content="googleaf4c29130aaf2b72.html"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/images/avatar.png"></div><div class="author-info__name text-center">whllhw</div><div class="author-info__description text-center">生活不止眼前的苟且，还有读不懂的诗和到不了的远方</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">37</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">仰头45℃爆笑</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="site-info"><div id="site-title">仰头45℃爆笑</div><div id="site-sub-title">生活不止眼前的苟且，还有读不懂的诗和到不了的远方</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/posts/2019/12/28/解决钉钉服务器出口IP不确定问题：自签名根证书-host-nginx反向代理/">解决钉钉服务器出口IP不确定问题：自签名根证书+hosts文件+nginx反向代理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-28</time><div class="content"><h1>问题来源</h1>
<p>企业内部应用一般部署在内网，没有固定的公网IP，这样在访问钉钉的API时就会被拦截下来。钉钉的服务器出口IP只支持一个统配符，出现不匹配的情况就会被拦截。</p>
<h1>解决方案比较</h1>
<p>当然存在多种解决方案，各有差别，但是本质都需要一个公网服务器，公网搭设一个代理服务：</p>
<ol>
<li>在代码中使用代理。对代码具有一定的侵入性。</li>
<li>使用系统代理。这样需要用PAC来选择代理的网址，对一些程序可能无效。</li>
<li>使用iptables转发到代理软件。仅限于linux可用。</li>
</ol>
<p>这里我介绍一种用反向代理的方法解决没有固定IP的方案。内网的windows服务器只需要一个根证书、改Hosts文件即可。</p>
<h1>解决方案</h1>
<h2 id="先决条件">先决条件</h2>
<ol>
<li>公网服务器且系统为Linux、固定的公网IP</li>
</ol>
<h2 id="步骤">步骤</h2>
<ol>
<li>
<p>生成自签名的根证书 + 域名证书<br>
<a href="https://2heng.xin/2018/12/16/your-own-ca-with-openssl/" target="_blank" rel="noopener">OpenSSL 自签 CA 及 SSL 证书</a>参考这篇文章即可。注意把域名改成<code>oapi.dingtalk.com</code>，将csr文件转换为pem文件。</p>
</li>
<li>
<p>在公网配置Nginx的反向代理，使用如下配置文件</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        # SSL configuration</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        listen [::]:443 ssl;</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate /home/ubuntu/certs/oapi.dingtalk.com.pem; # 公钥路径</span><br><span class="line">        ssl_certificate_key /home/ubuntu/certs/oapi.dingtalk.com.key; # 私钥路径</span><br><span class="line">        ssl_session_timeout  5m;</span><br><span class="line">        ssl_protocols  SSLv2 SSLv3 TLSv1 TLSv1.2;</span><br><span class="line">        ssl_ciphers  &quot;HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES&quot;;</span><br><span class="line">        ssl_prefer_server_ciphers   on;</span><br><span class="line">        server_name oapi.dingtalk.com;</span><br><span class="line">        location ~ / &#123;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            #proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass https://oapi.dingtalk.com;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>在内网服务器，把根证书导入到受信任的根证书颁发机构<br>
<img src="/images/%E5%AE%89%E8%A3%85CA%E6%A0%B9%E8%AF%81%E4%B9%A6.png" alt=""></p>
</li>
<li>
<p>在内网服务器，设置Hosts文件</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;公网ip&gt;  oapi.dingtalk.com</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>重启nginx，即可在内网服务器上访问反代的钉钉API</li>
</ol>
<h2 id="简要分析原理">简要分析原理</h2>
<p>本地hosts文件强制解析到自有服务器上，中间的证书是自签名认证的，服务器获取到请求后转发给真正的钉钉服务器，这样出口IP就确定了下来，能过验证。注意根证书的私钥不要泄露了，否则带来中间人攻击的风险。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/2019/08/19/Linux 和 Windows 双系统共用蓝牙设备/">Linux 和 Windows 双系统共用蓝牙设备</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-19</time><div class="content"><h1>背景</h1>
<p>我安装的双系统，有时需要切换到Linux下工作，有时又需要在Windows下处理事务。我使用的蓝牙键盘是Logitech K380，可以同时容纳三个设备，但是每次在一个系统下配置使用后，重启到另外一个系统便不能再连接，需要重新配对。本文参考了网络上其他的文章，可先看参考文章。话不多说，直接开始！</p>
<p>首先，了解一下原因。蓝牙配对是根据设备的MAC地址和随机生成的密钥来连接的，相同设备的MAC地址是相同的，但是系统随机生成的密钥不同，所以解决的思路就是把密钥改成相同的即可。</p>
<p>由于我Windows已经配对了，我参考南浦月的博客步骤如下：</p>
<ol>
<li>Windows配对键盘（生成配置文件）</li>
<li>Linux下配对键盘（读取key）</li>
<li>回到Windows修改配对key</li>
</ol>
<h1>使用dumplive在Linux下读取Windows注册表</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sda3 /mnt          #假设 sda3 是 Windows 系统盘</span><br><span class="line">cd /mnt/Windows/System32/config    #注意路径大小写</span><br><span class="line">dumphive system ~/system.reg</span><br></pre></td></tr></table></figure>
<p>这里直接参考原博客即可，但是我的Win10（版本1803）对应的键值与原文中的</p>
<blockquote>
<p>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BTHPORT\Parameters\Keys&lt;本机蓝牙 MAC&gt;&lt;鼠标蓝牙 MAC&gt;</p>
</blockquote>
<p>不一样，使用<code>grep -Pn 'BTHPORT.*(\\[\da-f]{12}){2}' ~/system.reg</code> 正则无法匹配，我这里的键值是</p>
<blockquote>
<p>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BTHPORT\Parameters\Keys\441ca8xxxxx（本机蓝牙MAC）</p>
</blockquote>
<p>最后的密钥在键为键盘蓝牙MAC下。<br>
剩余步骤直接按原文操作即可。</p>
<h1>修改Linux下蓝牙配对信息</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">cd /var/lib/bluetooth/60:57:XX:XX:XX:XX # 进入本机蓝牙设备的配对信息</span><br><span class="line">cd EB:50:XX:XX:XX:XX # 进入键盘蓝牙目录</span><br></pre></td></tr></table></figure>
<p>修改该目录下的info文件，把key改对即可。注意去掉冒号，全大写，这里与原文鼠标的配置文件不同。（不需要反转字符）</p>
<h1>参考</h1>
<p><a href="https://blog.nanpuyue.com/2018/040.html" target="_blank" rel="noopener">https://blog.nanpuyue.com/2018/040.html</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/2019/08/19/Java并发之并发容器ConcurrentHashMap/">Java并发之并发容器ConcurrentHashMap</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-19</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h1>为什么要使用ConcurrentHashMap？</h1>
<ol>
<li>HashMap线程不安全，多个线程同时<code>putVal</code>会造成死循环（在扩容过程中，链表成环）<br>
扩容过程：遍历旧桶，对每个桶里的链表entry，使用头插法放入对应新桶，即与原来的顺序相反。头插法过程中会改变头节点，当一个线程resize进度快于另外一个线程时，就会出现前一个链表插入后的后继仍然时原来的后继节点，这就出现了环。<a href="https://my.oschina.net/hosee/blog/673521" title="参考" target="_blank" rel="noopener">参考</a><br>
<img src="http://static.oschina.net/uploads/space/2016/0511/150544_UYcT_2243330.jpg" alt=""></li>
<li>Hashtable效率底下，（依靠synchronized来同步方法）不能多读。</li>
<li>ConcurrentHashMap利用锁分段技术，用多把锁提升了并发访问，同时扩容也只涉及到单个段，不涉及全部的段</li>
</ol>
<h1>ConcurrentHashMap结构</h1>
<h1>参考</h1>
<p>Java并发编程的技术</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/2019/05/09/Java并发之线程池/">Java并发之线程池</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-09</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h1>线程池介绍</h1>
<p>线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。</p>
<h1>使用线程池的好处</h1>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h1>类图</h1>
<p><img src="https://user-gold-cdn.xitu.io/2017/4/22/8f025e56062328e4ac36e3c988e30d27?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h2 id="executor-接口">Executor 接口</h2>
<p>只有一个方法<code>void execute(Runnable command)</code>，用来提交一个任务，根据不同的Executor实现，可能是创建一个新工作线程或者是复用工作线程运行<br>
根据线程池的容量或阻塞队列的容量决定是否放入阻塞队列中，或者拒绝接受传入的任务。</p>
<h2 id="executorservice接口">ExecutorService接口</h2>
<p>继承自Executor，并提供了管理终止的方法<code>shutdown()</code>（不再接受新任务，等待任务结束）<code>shutdownNow()</code>（除此之外还尝试终止运行中的任务）<br>
<code>Future submit(Runnable command)</code> 提供一个能查询结果的接口</p>
<h2 id="scheduledexecutorservice接口">ScheduledExecutorService接口</h2>
<p>ScheduledExecutorService扩展ExecutorService接口并增加了schedule方法。调用schedule方法可以在指定的延时后执行一个Runnable或者Callable任务。ScheduledExecutorService接口还定义了按照指定时间间隔定期执行任务的scheduleAtFixedRate()方法和scheduleWithFixedDelay()方法。</p>
<h1>ThreadPoolExecutor分析</h1>
<p>继承自AbstractExecutorService，也是实现了ExecutorService接口。<br>
重要字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">// runState is stored in the high-order bits</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>
<p>ctl是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。<br>
<strong>为什么要一个Integer表示两个值</strong>：在多线程的环境下，运行状态和有效线程数量往往需要保证统一，不能出现一个改而另一个没有改的情况，如果将他们放在同一个 AtomicInteger中，利用 AtomicInteger 的原子操作，就可以保证这两个值始终是统一的。Doug Lea大神牛逼！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务；</span><br><span class="line">SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）；</span><br><span class="line">STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；</span><br><span class="line">TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。</span><br><span class="line">TERMINATED：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。</span><br></pre></td></tr></table></figure>
<pre><code>ctl计算方法
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br><span class="line">private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法">构造方法</h2>
<p>关键参数：</p>
<ol>
<li>
<p><strong>corePoolSize</strong>：核心线程数量</p>
</li>
<li>
<p><strong>maximumPoolSize</strong>：最大线程数量</p>
</li>
<li>
<p><strong>workQueue</strong>：等待队列，当任务提交时，如果线程池中的线程数量大于等于corePoolSize的时候，把该任务封装成一个Worker对象放入等待队列<br>
当有新任务用execute()提交时会执行以下判断：</p>
<ol>
<li>运行线程少于corePoolSize则创建新的线程来处理任务，即使线程池中其他线程是空闲的</li>
<li>当线程池中的线程数量大于等于corePoolSize且小于maximumPoolSize，则当workQueue满的时候才创建新的线程去处理任务</li>
<li>若设置的corePoolSize和maximumPoolSize相同，则创建的线程池大小固定，workQueue未满时直接放到workQueue，等待有空闲的线程去取任务</li>
<li>当运行线程数大于等于maximumPoolSize时，若workQueue已满，则执行handler来拒绝任务<br>
有如下的阻塞队列：</li>
<li><strong>SynchronousQueue</strong>（CachedThreadPool中使用）必须匹配生产者和消费者才会结束阻塞过程，否则一直阻塞到其他的线程执行take/offer，超时返回false。</li>
<li><strong>LinkedBlockingQueue</strong> 无界队列，链表实现。如果使用这种方式，那么线程池中能够创建的最大线程数就是corePoolSize，而maximumPoolSize就不会起作用了。当线程池中所有的核心线程都是RUNNING状态时，这时一个新的任务提交就会放入等待队列中。</li>
<li><strong>ArrayBlockingQueue</strong> 有界队列。使用该方式可以将线程池的最大线程数量限制为maximumPoolSize，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。</li>
</ol>
</li>
<li>
<p><strong>keepAliveTime</strong>：线程池维护线程所允许的空闲时间。<br>
线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</p>
</li>
<li>
<p><strong>threadFactory</strong>：用于创建自定义线程,指定优先级、名称。</p>
</li>
<li>
<p><strong>handler</strong>：它是RejectedExecutionHandler类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。</p>
<ol>
<li>AbortPolicy：直接抛出异常，这是默认策略</li>
<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>
<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li>DiscardPolicy：直接丢弃任务；</li>
</ol>
</li>
</ol>
<h2 id="execute方法">execute方法</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">        if (command == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            if (addWorker(command, true))</span><br><span class="line">                return;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            int recheck = ctl.get();</span><br><span class="line">            if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            else if (workerCountOf(recheck) == 0) // 防止唯一的线程挂掉，无法从工作队列取数据</span><br><span class="line">                addWorker(null, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!addWorker(command, false))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>大概进行过程如下，addWorker中也有判断线程数的逻辑，加上这里双重校验线程池状态，所以有点混乱：</p>
<ol>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程（<strong>addWorker</strong>）来执行新提交的任务；</li>
<li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；</li>
<li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize（<strong>addWorker</strong>内检查）且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；</li>
<li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。<br>
即是，尝试下面的操作，满足则提交运行，新建线程或者是放入队列中：</li>
<li>核心线程数是否已满？</li>
<li>阻塞队列是否已满？</li>
<li>最大线程数是否已满？</li>
<li>都不满足则拒绝任务</li>
</ol>
<h2 id="addworker方法">addWorker方法</h2>
<p>addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数 用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize。<br>
主要思路：</p>
<ol>
<li>第一层for，检查运行状态。获取当前线程池的运行状态，如果大于等于SHUTDOWN，则表示不再接收新的任务。并且以下条件有一个不满足则返回false：
<ol>
<li>线程池的状态等于SHUTDOWN（则可继续执行阻塞队列中的任务）</li>
<li>firstTask为空（不能接受新的任务）</li>
<li>阻塞队列不为空（队列中没有任务，不需要再添加线程）</li>
</ol>
</li>
<li>第二层for，尝试增加workCount，获取当前的线程数，若大于最大线程数（maximumPoolSize）不能再创建返回false。</li>
<li>否则尝试增加workCount（AtomicInteger，底层是CAS），成功跳出for，进入创建进程的代码块</li>
<li>失败则重新获取线程池的状态，于开始记录下的值对比，不等说明运行状态被改变，继续第一层for。相等时继续第二层for</li>
<li>此时已经完成了<strong>workCount</strong>的增加，开始执行Worker的创建代码。<code>new Worker(firstTask)</code></li>
<li>获取一把可重入锁（mainLock），再次判断线程池的状态（是<strong>RUNNING</strong>或<strong>SHUTDOWN</strong>且<strong>firstTask</strong>为空），不符合则跳出try块，执行清理刚才的线程工作（<strong>addWorkerFaild(w)</strong>)。返回false</li>
<li>否则添加刚才创建的worker到workers（HashSet）里，并开启调用worker里的thread成员start，开启线程执行，更新largestPoolSize（记录出现的最大线程数量），返回true</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line">        // Check if queue empty only if necessary.</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == null &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            if (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line">            c = ctl.get();  // Re-read ctl</span><br><span class="line">            if (runStateOf(c) != rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean workerStarted = false;</span><br><span class="line">    boolean workerAdded = false;</span><br><span class="line">    Worker w = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        w = new Worker(firstTask);</span><br><span class="line">        final Thread t = w.thread;</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                int rs = runStateOf(ctl.get());</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                    if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    int s = workers.size();</span><br><span class="line">                    // largestPoolSize记录着线程池中出现过的最大线程数量</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>Worker类</h1>
<p>线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private final class Worker</span><br><span class="line">        extends AbstractQueuedSynchronizer</span><br><span class="line">        implements Runnable</span><br></pre></td></tr></table></figure>
<p>继承了AQS、实现了Runnable接口，并有firstTask（记录保存传入的任务），thread（在调用构造函数时用ThreadFactory创建的，保存处理任务的线程）。构造函数中执行了<code>this.thread = getThreadFactory().newThread(this);</code>新建一个线程，newThread方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。<br>
Worker继承了AQS，使用AQS来实现独占锁的功能。不使用ReentrantLock（可重入）：</p>
<ol>
<li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中</li>
<li>如果正在执行任务，则不应该中断线程</li>
<li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断</li>
<li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；</li>
<li>之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。</li>
</ol>
<h2 id="worker-runworker方法">Worker.runWorker方法</h2>
<p>run方法中调用了该方法来执行任务。主要工作是：</p>
<ol>
<li>while循环不断地通过getTask()方法获取任务；</li>
<li>getTask()方法从阻塞队列中取任务；</li>
<li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；</li>
<li>调用task.run()执行任务；</li>
<li>如果task为null则跳出循环，执行processWorkerExit()方法；</li>
<li>runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。<br>
这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。</li>
</ol>
<h2 id="gettask方法">getTask方法</h2>
<p>getTask方法用来从阻塞队列中取任务<br>
这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。<br>
什么时候会销毁？当然是runWorker方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。<br>
getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法。</p>
<h2 id="processworkerexit方法">processWorkerExit方法</h2>
<p>至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束，如图所示：<br>
<img src="https://user-gold-cdn.xitu.io/2017/4/22/fb66e616aa6da061f92d0b4eebb64b7f" alt=""></p>
<h2 id="tryterminate方法">tryTerminate方法</h2>
<p>tryTerminate方法根据线程池状态进行判断是否结束线程池。</p>
<ol>
<li>当前线程池的状态为以下几种情况时，直接返回，不能结束线程池：
<ol>
<li>RUNNING，因为还在运行中，不能停止；</li>
<li>TIDYING或TERMINATED，因为线程池中已经没有正在运行的线程了；</li>
<li>SHUTDOWN并且等待队列非空，这时要执行完workQueue中的task；</li>
</ol>
</li>
<li>如果线程数量不为0，则中断一个空闲的工作线程，并返回</li>
<li>获取this.mainLock锁，尝试设置状态TIDYING（ 线程数已经为0，调用完terminated，即改变为TERMINATED），调用<code>terminated()</code>后设置状态为TERMINATED</li>
</ol>
<h2 id="shutdown方法">shutdown方法</h2>
<p>shutdown方法要将线程池切换到SHUTDOWN状态，并调用interruptIdleWorkers方法请求中断所有空闲的worker，最后调用tryTerminate尝试结束线程池。</p>
<h2 id="interruptidleworkers方法">interruptIdleWorkers方法</h2>
<p>interruptIdleWorkers遍历workers中所有的工作线程，若线程没有被中断tryLock成功，就中断该线程。</p>
<h2 id="shutdownnow方法">shutdownNow方法</h2>
<p>shutdownNow方法执行完之后调用tryTerminate方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为TERMINATED。<br>
shutdownNow方法与shutdown方法类似，不同的地方在于：</p>
<ol>
<li>设置状态为STOP；</li>
<li>中断所有工作线程，无论是否是空闲的；</li>
<li>取出阻塞队列中没有被执行的任务并返回。<br>
shutdownNow方法执行完之后调用tryTerminate方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为TERMINATED。</li>
</ol>
<h2 id="问题">问题</h2>
<p>为什么需要持有mainLock？因为workers是HashSet类型的，不能保证线程安全。</p>
<p>在runWorker方法中，执行任务时对Worker对象w进行了lock操作，为什么要在执行任务的时候对每个工作线程都加锁呢？<br>
下面仔细分析一下：</p>
<ul>
<li>在getTask方法中，如果这时线程池的状态是SHUTDOWN并且workQueue为空，那么就应该返回null来结束这个工作线程，而使线程池进入SHUTDOWN状态需要调用shutdown方法；</li>
<li>shutdown方法会调用interruptIdleWorkers来中断空闲的线程，interruptIdleWorkers持有mainLock，会遍历workers来逐个判断工作线程是否空闲。但getTask方法中没有mainLock；</li>
<li>在getTask中，如果判断当前线程池状态是RUNNING，并且阻塞队列为空，那么会调用workQueue.take()进行阻塞；</li>
<li>如果在判断当前线程池状态是RUNNING后，这时调用了shutdown方法把状态改为了SHUTDOWN，这时如果不进行中断，那么当前的工作线程在调用了workQueue.take()后会一直阻塞而不会被销毁，因为在SHUTDOWN状态下不允许再有新的任务添加到workQueue中，这样一来线程池永远都关闭不了了；</li>
<li>由上可知，shutdown方法与getTask方法（从队列中获取任务时）存在竞态条件；</li>
<li>解决这一问题就需要用到线程的中断，也就是为什么要用interruptIdleWorkers方法。在调用workQueue.take()时，如果发现当前线程在执行之前或者执行期间是中断状态，则会抛出InterruptedException，解除阻塞的状态；</li>
<li>但是要中断工作线程，还要判断工作线程是否是空闲的，<strong>如果工作线程正在处理任务，就不应该发生中断</strong>；</li>
<li>所以Worker继承自AQS，在工作线程处理任务时会进行lock，interruptIdleWorkers在进行中断时会使用tryLock来判断该工作线程是否正在处理任务，如果tryLock返回true，说明该工作线程当前未执行任务，这时才可以被中断。</li>
</ul>
<h1>总结</h1>
<ol>
<li>分析了线程的创建，任务的提交，状态的转换以及线程池的关闭；</li>
<li>这里通过execute方法来展开线程池的工作流程，execute方法通过corePoolSize，maximumPoolSize以及阻塞队列的大小来判断决定传入的任务应该被立即执行，还是应该添加到阻塞队列中，还是应该拒绝任务。</li>
<li>介绍了线程池关闭时的过程，也分析了shutdown方法与getTask方法存在竞态条件；</li>
<li>在获取任务时，要通过线程池的状态来判断应该结束工作线程还是阻塞线程等待新的任务，也解释了为什么关闭线程池时要中断工作线程以及为什么每一个worker都需要lock。</li>
</ol>
<h1>参考</h1>
<p><a href="https://juejin.im/entry/58fada5d570c350058d3aaad" target="_blank" rel="noopener">https://juejin.im/entry/58fada5d570c350058d3aaad</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/2019/05/09/Java并发包之ReentrantLock、AbstractQueuedSynchronizer/">Java并发包之ReentrantLock、AbstractQueuedSynchronizer</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-05-09</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h1>ReentrantLock介绍</h1>
<p>ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。<br>
与<strong>synchronized</strong>作用相同（隐式支持重入性）<br>
**synchronized实现：**JVM中对对象头的操作。获取自增、释放自减方式实现重入。<strong>monitorenter</strong> <strong>monitorexit</strong></p>
<h2 id="重入性实现原理">重入性实现原理</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">    private final Sync sync;</span><br><span class="line">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br></pre></td></tr></table></figure>
<p>可知内部有个Sync对象，继承自AQS。lock方法和unlock方法都是代理的Sync对象。默认构造函数是Sync非公平锁。<strong>要理解可重入锁，则就是理解这几个Sync的实现。</strong></p>
<p>可重入如何解决：</p>
<ol>
<li>在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功</li>
<li>由于锁会被获取n次，那么只有锁在被释放同样的n次之后，该锁才算是完全释放成功</li>
</ol>
<h2 id="sync抽象类">Sync抽象类</h2>
<p>继承AQS，重写了<code>nonfairTryAcquire</code>方法，分析可知其流程很简单，利用<code>state</code>字段记录获取的锁数量。当无锁时直接尝试获取，注意只尝试一次没有<strong>自旋CAS</strong>。当有锁时检查是否当前线程获取的锁，是直接则锁数量+1，没有用到CAS。<br>
获取锁的过程【<code>nonfairTryAcquire</code>】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    //1. 如果该锁未被任何线程占有，该锁能被当前线程获取</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   //2.若被占有，检查占有线程是否是当前线程</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        // 3. 再次获取，计数加一</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>释放也是比较简单，先判断是否是当前获取的锁，再直接锁的数量减少，若减少到0则标记当前获取线程为null。注意只有获取锁的时候才用CAS，其他的情况包括：其他线程获取锁，同一线程获取的情况是单线程直接set即可！<br>
释放锁的过程：【<code>tryRelease</code>】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    //1. 同步状态减1</span><br><span class="line">    int c = getState() - releases;</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        //2. 只有当同步状态为0时，锁成功被释放，返回true</span><br><span class="line">        free = true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    // 3. 锁未被完全释放，返回false</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br></pre></td></tr></table></figure>
<p>重入锁的释放必须得等到同步状态为0时锁才算成功释放，否则锁仍未释放。</p>
<h2 id="nonfairsync实现类">NonfairSync实现类</h2>
<p>继承之Sync抽象类，只重写了lock方法和tryAcquire方法。<br>
同理，无锁时尝试获取，有锁时请求获取一把，这里会进入到AQS中，AQS会把当前线程加入同步队列并调用LockSupport.park挂起当前线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">            if (compareAndSetState(0, 1))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            else</span><br><span class="line">                acquire(1);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>释放时则是调用了AQS的<code>release</code>，其又执行了Sync抽象类的<code>tryRelease</code>方法，释放完所有锁时会<code>unpark</code>等待队列第一个线程。</p>
<h2 id="fairsync实现类">FairSync实现类</h2>
<p>唯一的区别就是在尝试获取锁的时候，会判断同步队列当前是否有节点在等待、当前节点是否有前驱节点，若有则表示有线程比当前线程更早地请求获取锁，则拒绝本次获取锁的请求，加入到同步队列，并挂起线程。符合FIFO。</p>
<p>这段代码的逻辑与nonfairTryAcquire基本上一致，唯一的不同在于增加了hasQueuedPredecessors的逻辑判断，方法名就可知道该方法用来<strong>判断当前节点在同步队列中是否有前驱节点</strong>的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁。</p>
<h2 id="公平锁和非公平锁利弊">公平锁和非公平锁利弊</h2>
<ol>
<li>公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，<strong>造成“饥饿”现象</strong>。</li>
<li>公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，<strong>保证了系统更大的吞吐量</strong>。</li>
</ol>
<h1>AbstractQueuedSynchronizer</h1>
<p><strong>AbstractQueuedSynchronizer</strong>是被很多类用于实现同步（CountDownLatch、CycliBarrier、ReentrantLock、ReentrantReadWriteLock），ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。<br>
不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在上层已经帮我们实现好了。</p>
<h2 id="lock接口">Lock接口</h2>
<p>concurrent包的关键接口，提供了和synchronized相同的功能，不过要显式加解锁，但需要在finally块内保证解锁。</p>
<h1>AQS（AbstractQueuedSynchronizer）同步器</h1>
<p>用于构建锁和同步器的框架，很多juc中都用其来构建同步器。（ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask）</p>
<h2 id="核心思想">核心思想</h2>
<p><img src="https://q.whllhw.xyz/wp-content/uploads/2019/04/CLH.png" alt=""><br>
底层：CAS，在C++内使用汇编CPU指令</p>
<h2 id="设计模式：模板方法">设计模式：模板方法</h2>
<p>一些方法开放给子类进行重写，而同步器给同步组件所提供模板方法又会重新调用被子类所重写的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    //  throw new UnsupportedOperationException(); // 父类实现</span><br><span class="line">    return nonfairTryAcquire(acquires); // NonfairSync子类实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AQS中的模板方法<code>acquire</code>又调用到了子类重写的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<ol>
<li>同步组件（这里不仅仅是可重入锁，还包括CountDownLatch等）的实现依赖于同步器AQS，在同步组件实现中，使用AQS的方式被推荐定义继承AQS的静态内存类；</li>
<li>AQS采用模板方法进行设计，AQS的protected修饰的方法需要由继承AQS的子类进行重写实现，当调用AQS的子类的方法时就会调用被重写的方法；</li>
<li>AQS负责同步状态的管理，线程的排队，等待和唤醒这些底层操作，而Lock等同步组件主要专注于实现同步语义；</li>
<li>在重写AQS的方式时，使用AQS提供的<code>getState()</code>,<code>setState()</code>,<code>compareAndSetState()</code>方法进行修改同步状态</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/2019/04/15/Java并发知识整理/">Java并发知识整理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-15</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h1>笔试题</h1>
<h2 id="线程间协作方式：-wait-notify-notifyall">线程间协作方式： wait notify notifyAll</h2>
<p>都是__Object类的final native方法__</p>
<ol>
<li>调用wait()能阻塞当前线程，必须拥有当前对象的monitor</li>
<li>notify()能唤醒一个正等待对象的monitor的线程</li>
<li>notifyAll()能唤醒等待monitor的线程</li>
</ol>
<p>由1可知，调用wait()方法必须在同步块、方法中调用。<br>
调用wait()后则交出当前对象的monitor，进入等待状态，（注意与Thread.sleep的区别）<br>
使用notify()唤醒任意一个等待该monitor的线程，也必须在同步块中使用。<br>
唤醒后不会立即获得monitor，等待退出synchronized块，释放对象锁后才能得到锁执行。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/2019/04/15/JVM知识整理/">JVM知识整理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-15</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h1>前言</h1>
<p>与计网的那篇一样，整理我看过的JVM知识。我刷完了B站的视频，配合《深入理解Java虚拟机》使用。最有意思是书中的实战部分，内存结构的时候，触发不同内存区域的OOM！没系统整理时，别问，一问就GG。哈哈，每天尽力更新整理，攒面试人品了！</p>
<h1>思维导图</h1>
<p><img src="/images/file_1555342244000.png" alt=""><br>
内容太多了，先不展开导图</p>
<h1>Java内存区域</h1>
<h2 id="导图">导图</h2>
<p><img src="/images/file_1555344369000.png" alt=""></p>
<h3 id="内存三大块：">内存三大块：</h3>
<h4 id="1-堆">1. 堆</h4>
<p>分为年轻代（Eden、From Survivor、To Survivor，大小比例8:1:1）、老年代。<br>
分区原因具体涉及到__GC__</p>
<h5 id="存放内容">存放内容</h5>
<p>对象实例<br>
数组</p>
<h5 id="转化过程：">转化过程：</h5>
<p>新对象在eden区分配（内存不够会在老年代分配），一次GC存活则进入s0、s1中，存活15代进入老年代</p>
<h5 id="异常抛出">异常抛出</h5>
<p>OOM</p>
<h4 id="2-方法区-non-heap">2. 方法区（Non-heap）</h4>
<p>又称永久代</p>
<h5 id="存放内容-v2">存放内容:</h5>
<p>类信息<br>
常量<br>
静态变量<br>
JIT编译代码<br>
PS：JDK8移除了方法区，把这些数据放到了直接内存的元数据区<br>
常量池信息，存放编译器生成的字面量和符号引用，JDK7移动到堆上存储</p>
<h5 id="异常抛出：">异常抛出：</h5>
<p>OOM</p>
<h4 id="3-栈">3. 栈</h4>
<p>分为虚拟机栈、本地方法栈。<br>
64位长度long和double占用两个局部变量空间（Slot）其他的占用1个</p>
<h5 id="存放内容-v3">存放内容</h5>
<ol>
<li>局部变量表（编译期完成，对应基本数据类型、对象引用）</li>
<li>操作数栈（字节码相关）</li>
<li>动态链接</li>
<li>方法出口</li>
<li>常量引用</li>
<li>小对象（无逃逸时，自动回收）</li>
</ol>
<h5 id="异常">异常</h5>
<p>OOM（无法动态扩展时）<br>
SOF（大于允许深度时）</p>
<h4 id="4-程序计数器">4. 程序计数器</h4>
<p>存放当前线程字节码指令地址，无OOM抛出</p>
<h4 id="5-直接内存">5. 直接内存</h4>
<h5 id="1-nio">1. NIO</h5>
<p>基于通道（channel）和缓存区（buffer）<br>
直接使用Native函数分配堆外内存（__DirectByteBuffer__对象引用这块内存）</p>
<ol>
<li>避免Java堆、Native堆来回复制数据</li>
<li>不受Java堆限制（但受本机总内存限制）</li>
</ol>
<h1>垃圾回收</h1>
<p><img src="/images/file_1555416270000.png" alt=""></p>
<h2 id="算法分类">算法分类</h2>
<ol>
<li>
<p>引用计数法<br>
原理：维护对象的引用计数，为0时回收<br>
问题：</p>
<ol>
<li>性能开销</li>
<li>循环引用问题</li>
</ol>
</li>
<li>
<p>标记-清除法<br>
原理：从根节点出发，标记所有可达对象，把不可达对象删除</p>
</li>
<li>
<p>标记-压缩法<br>
原理：与标记-清除法相同，增加了移动到一侧，清空边界以外的点。以消除碎片</p>
</li>
<li>
<p>复制算法<br>
<img src="/images/file_1555415892000.png" alt=""><br>
原理：两块相同大小的空间，每次把存活对象放到另一块，清空本块。并把大对象放到老年代。<br>
问题：</p>
<ol>
<li>浪费一半空间</li>
<li>不适合存活过多的内存区域（老年代）</li>
</ol>
</li>
</ol>
<h2 id="分代思想">分代思想</h2>
<p>少量对象，适合复制算法<br>
大量存活，适合标记清理、压缩</p>
<h2 id="一些概念">一些概念</h2>
<ol>
<li>什么是可触及性？<br>
以下是可触及的：
<ol>
<li>栈中的引用对象</li>
<li>方法区的静态成员</li>
<li>常量的引用</li>
<li>JNI方法栈中的引用对象</li>
</ol>
</li>
<li>什么时候可复活？<br>
finalize()中复活对象（当然只会复活一次）</li>
<li>为什么避免使用finalize？
<ol>
<li>无法确定GC的时间</li>
<li>为什么不使用更确定性的try catch finally呢？</li>
</ol>
</li>
<li>什么是Stop-The-World现象？<br>
多半是由GC引起的出现全局暂停的现象，（其他原因：Dump线程，死锁检查，堆Dump）</li>
<li>Stop-The-World有什么危害？
<ol>
<li>Java长时间无响应（老年代满出现这种情况）</li>
<li>考虑有集群的时候，会误判宕机，而出现主备切换（扯远了）</li>
</ol>
</li>
</ol>
<h2 id="术语">术语</h2>
<table>
<thead>
<tr>
<th>name</th>
<th>别名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>FUll GC</td>
<td>Major GC</td>
<td>清理整个堆</td>
</tr>
<tr>
<td>Old GC</td>
<td></td>
<td>清理老年代内存</td>
</tr>
<tr>
<td>Mxinor GC</td>
<td>Young GC</td>
<td>清理年轻代内存</td>
</tr>
</tbody>
</table>
<h2 id="具体算法">具体算法</h2>
<p><img src="/images/file_1555420503000.png" alt=""></p>
<h3 id="串行收集器-xx-useserialgc">串行收集器（-XX:UseSerialGC)</h3>
<p>毫无疑问，串行的效率最高（回收垃圾的效率），但是带来了较长的停顿。使用该参数则表示：<br>
	1. 新生代、老年代使用串行回收<br>
	2. 新生代使用复制算法<br>
	3. 老年代使用标记-压缩</p>
<h3 id="并行收集器-xx-useparnewgc">并行收集器（-XX: UseParNewGC）</h3>
<p>复制算法的实现，多线程并行复制，当然是在新生代使用。</p>
<h3 id="并行收集器-xx-useparallelgc-xx-useparalleloldgc">并行收集器（-XX: UseParallelGC,-XX: UseParallelOldGC）</h3>
<p>新生代使用复制算法，老年代使用标记-压缩（默认不并行，使用后面的才并行）</p>
<h3 id="cms-concurrent-mark-sweep-并发标记清除算法">CMS（Concurrent Mark Sweep）并发标记清除算法</h3>
<p>这个就要详细说说了。是标记-清除算法的并发实现。<br>
过程如下：<br>
	1. 初始标记（串行，暂停用户线程）<br>
		由根直接能标记到的对象，速度快<br>
	2. 并发标记（与用户线程并行）<br>
		标记全部可达对象<br>
	3. 重新标记（串行）<br>
		暂停整个应用程序，修正标记，准备清理了<br>
	4. 并发清理（与用户线程并行）<br>
		清理垃圾<br>
	5. 并发重置<br>
		开始下一个循环<br>
特点：<br>
	1. 停顿时间短，多次与用户线程并行<br>
	2. 并发时，系统吞吐量降低（GC线程与应用线程一起工作，应用吞土量当然降低了）<br>
	3. 清理不彻底（清理时与用户线程并行，期间产生的垃圾只能下次GC回收）<br>
使用注意事项：<br>
	1. 老年代使用（对象变化较小，重新标记、清理期间做的工作更加有效）<br>
	2. 不能在空间快满的时候清理，会出现Concurrent mod failure错误 。此时会使用串行收集器，得不偿失。<br>
	-XX:CMSInitiatingOccupancyFraction 设置触发GC的阈值<br>
几个参数：<br>
	-XX: UseConcMarkSweepGC（使用CMS）<br>
	-XX: UseCMSCompactAtFullCollection（Full GC后进行碎片整理）<br>
	-XX: CMSFullGCBeforeCompaction（进行几次GC后再进行碎片整理）<br>
	-XX:ParallelCMSThreads（CMS线程数量）</p>
<h3 id="如何减轻gc压力？？">如何减轻GC压力？？</h3>
<ol>
<li>软件架构的设计</li>
<li>代码编写</li>
<li>堆如何分配</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/2019/04/14/计算机网络知识整理/">计算机网络知识整理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-14</time><div class="content"><h1>计算机网络面试题</h1>
<h2 id="前言">前言</h2>
<p>3月份面头条、腾讯被问到很多的计网题。但是自己未学过，也只是在网上看些博客。不得不说博客质量真是参差不齐，甚至某博客平台文章一键转载，可以说是知识污染。朋友推荐看《计算机网络教程：自顶而下方法》也刷得懵懂，又去B站找了考研视频刷了几天，加上自己看视频、看书做的笔记，才对计网有了了解，区分了以前不懂、模糊的概念。这里做整理，为自己攒人品！</p>
<h2 id="思维导图">思维导图</h2>
<p><img src="/images/file_1555251089000.png" alt="思维导图"></p>
<h2 id="协议分层">协议分层</h2>
<p><img src="/images/file_1555257223000.png" alt="OSI参考模型，来源计算机网络教程：自顶而下方法"></p>
<h2 id="应用层">应用层</h2>
<h3 id="http协议">HTTP协议</h3>
<p>这里东西比较杂，就挑我面试的问题进行整理了</p>
<h4 id="http1-0-1-1中的区别">HTTP1.0、1.1中的区别</h4>
<h4 id="websocket-握手">WebSocket 握手</h4>
<h3 id="dns解析过程">DNS解析过程</h3>
<h4 id="dns服务器分类">DNS服务器分类</h4>
<ol>
<li>根DNS服务器：13台，分布在全球</li>
<li>顶级服务器：com org edu</li>
<li>权威服务器：提供域名管理服务，维护域名解析记录</li>
</ol>
<h4 id="查询过程">查询过程</h4>
<p><img src="/images/file_1555256606000.png" alt="查询过程"></p>
<p><img src="/images/file_1555256700000.png" alt="来源见水印"></p>
<h4 id="权威性">权威性</h4>
<ol>
<li>权威DNS：由域名解析商建设。在域名注册商设置的DNS服务器，对特定域名本身的管理（增、删、改）维护域名解析记录</li>
<li>非权威DNS：缓存DNS记录，缓存命中直接返回IP，未命中则逐级递归查询，由网络运营商建设，提供域名查询解析服务。</li>
</ol>
<h2 id="传输层">传输层</h2>
<h3 id="多路复用与多路分解">多路复用与多路分解</h3>
<ul>
<li>多路复用：应用层所有的应用进程都可以通过传输层再传输给网络层</li>
<li>多路分解：传输层从网络层接收到数据后交付给指定应用进程</li>
<li>TCP套接字:四元组（源IP，源端口，目的IP，目的端口）</li>
<li>UDP套接字:二元组（目的IP，目的端口）</li>
</ul>
<ol>
<li>服务器提供并行TCP套接字有限，原因：<strong>四元组资源耗尽</strong></li>
<li>多个报文段到达主机后，使用元组定向到不同的套接字</li>
</ol>
<h3 id="tcp">TCP</h3>
<h4 id="1-特点">1.特点</h4>
<h4 id="2-首部">2.首部</h4>
<h4 id="3-状态转换图">3.状态转换图</h4>
<p><img src="/images/file_1555253635000.png" alt="状态转换图"></p>
<h4 id="4-连接与断开">4.连接与断开</h4>
<h4 id="5-流量控制">5.流量控制</h4>
<h4 id="6-拥塞控制">6.拥塞控制</h4>
<h4 id="7-差错控制-可靠传输">7.差错控制、可靠传输</h4>
<h3 id="udp">UDP</h3>
<h4 id="1-特点-v2">1.特点</h4>
<h4 id="2-首部-v2">2.首部</h4>
<h4 id="3-与tcp区别-及应用场景">3.与TCP区别，及应用场景</h4>
<h2 id="网络层">网络层</h2>
<h2 id="数据链路层">数据链路层</h2>
<h2 id="物理层">物理层</h2>
<h2 id="一些面试题">一些面试题</h2>
<ol>
<li>TCP三次握手，四次挥手？详细流程（包括每个状态）为什么需要三次握手？为什么需要四次挥手？为什么TIME_WAIT要等待2MSL？</li>
<li>OSI七层模型与TCP/IP四层模型，各层的作用？</li>
<li>DNS域名系统</li>
<li>ARP地址解析协议</li>
<li>TCP与UDP的区别、使用场景</li>
<li>滑动窗口协议</li>
<li>TCP的拥塞控制</li>
<li>CDN内容分发网络</li>
<li>Session是什么？什么作用？特点？</li>
<li>HTTP1.1 新特性</li>
<li>HTTP状态码，12345各代表什么含义，重要的一些状态码要记住</li>
<li>HTTP请求报文、响应报文格式</li>
<li>HTTP八种请求方法</li>
<li>HTTP与HTTPS</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://book.douban.com/subject/21267825/" title=" 《计算机网络自顶而下》" target="_blank" rel="noopener">计算机网络教程：自顶而下方法</a></li>
<li><a href="https://www.bilibili.com/video/av33595294" title="全网最全王道计算机网络 计算机网络王道讲书学习视频" target="_blank" rel="noopener">[全网最全王道计算机网络]计算机网络王道讲书学习视频</a></li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/2019/04/01/Servlet学习总结/">Servlet学习总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/java/">java</a></span><div class="content"><h1>前言</h1>
<p>Spring Boot 中的spring-boot-web-starter中默认配置的Web容器就是Tomcat，而Tomcat是实现了Servlet规范的Web容器，以前在项目中经常用到，但是由于Spring Boot的约定先于配置大大隐藏了Tomcat的复杂性，还有Servlet的一些底层实现，导致在项目用到一些Servlet的东西却不知道其接口之间的关系。加上最近找实习也遇到面试官问这些问题，之前零散在网上看的不系统，回答的时候有点懵，于是花了一天去较为系统的了解这个Java Web中的重要接口。</p>
<h1>思维导图</h1>
<p>先看看我导图，然后再自底向上一一道来，归纳得不全，只有常见的接口，接口的实现也没有时间细看。<br>
<img src="https://upload-images.jianshu.io/upload_images/10215367-a441953f2f80b8b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Servlet"></p>
<h1>什么是Servlet？</h1>
<p>Servlet（server applet）是JavaEE（位于javax.servlet）中的编程规范，用在浏览器与Java之间访问交互，只需要实现了Servlet就可以在任意符合其规范的Web容器应用服务器（Tomcat JBoss Wildfly）中运行你的后端代码。从而实现了一次编写到处部署（面向接口编程的好处）！</p>
<h1>Servlet有哪些常见的接口？</h1>
<h2 id="servlet接口">Servlet接口</h2>
<p>留给程序员去实现的一个重要接口，编写业务逻辑，SQL查询之类的</p>
<ol>
<li><strong>void init(ServletConfig config)</strong></li>
</ol>
<ul>
<li>servlet 初始化方法，在用户访问时会实例化，该方法会被首次调用，可用于资源连接、打log</li>
</ul>
<ol start="2">
<li><strong>void destory()</strong></li>
</ol>
<ul>
<li>对象被销毁时调用，放一些资源关闭的一些代码</li>
</ul>
<ol start="3">
<li><strong>void service(ServletRequest req,ServletResponse res)</strong></li>
</ol>
<ul>
<li>最重要的一个方法，当请求到来的时候会实例出Request Response并调用该方法，常常在这里实现业务逻辑了</li>
</ul>
<h2 id="servletconfig接口">ServletConfig接口</h2>
<p>用于初始化Servlet对象时使用，已由Tomcat实现。</p>
<ol>
<li>读取web.xml中的配置信息__init-param__表示，可以用于配置数据库连接等信息。<br>
2 . 获取ServletContext</li>
</ol>
<h2 id="servletcontext接口">ServletContext接口</h2>
<p>一个完整的webapp的应用上下文，已由Tomcat实现。<br>
启动时创建，服务关闭时被摧毁。可存放__context-param__环境变量、运行时全局共享的一些数据。</p>
<h2 id="httpservlet抽象类">HttpServlet抽象类</h2>
<p>继承自GenericServlet（implements Servlet）的抽象类，提供了一些通用的实现：</p>
<ol>
<li>ServletConfig在init时保存为引用</li>
<li>在service实现HTTP请求方式的解析和分发调用算法</li>
<li><strong>doGet</strong>、__doPost__等方法默认抛出405错误（不支持的请求方式）</li>
<li>实现HTTP请求头的缓存信息解析</li>
<li>强制把ServletRequest转换成HttpServletRequest调用service方法</li>
</ol>
<h2 id="httpservletrequest接口">HttpServletRequest接口</h2>
<p>继承自__ServletRequest__，添加了HTTP协议的接口，在__service__方法中使用。添加了：</p>
<ol>
<li>url的参数获取（表单、url）</li>
<li>获取remoteIp</li>
<li>获取转发器（res.getRequestDispatcher(&quot;/b&quot;).forward(req,res)）</li>
<li>重定向(res.sendRedirect）与转发器的区别</li>
<li>getCookie</li>
<li>getSession</li>
</ol>
<h2 id="httpservletresponse">HttpServletResponse</h2>
<p>继承自ServletResponse，同样拓展了HTTP相关的东西，如：</p>
<ol>
<li>sendError发送HTTP状态码和信息</li>
<li>getOutPutStream</li>
<li>addCookie</li>
</ol>
<h2 id="httpsession接口">HttpSession接口</h2>
<p>可用__HttpServletRequest.getSession()__获取当前连接的会话。</p>
<ol>
<li>获取sessionId</li>
<li>获取过期时间</li>
<li>setAttribute、getAttribute、removeAttribute存放会话数据</li>
</ol>
<h2 id="cookie接口">Cookie接口</h2>
<p>可用__HttpServletRequest.getCookie()__获取当前连接的cookie，__res.addCookie__发送给浏览器cookie</p>
<ol>
<li>setPath，以最后的斜杠匹配，默认为当前uri发送（/a/b/c匹配/a/b/）</li>
<li>setMaxAge，过期时间（=0直接删除，&lt;0不存储，&gt;0x秒失效）</li>
</ol>
<h1>运行时接口对应关系</h1>
<ol>
<li>一个Servlet对象对应一个Config，在web.xml定义的每个servlet的配置</li>
<li>一个webapp对应ServletContext，所有servlet共享同一个，在web.xml配置整个webapp的配置</li>
<li>一个请求对应HttpServletRequest，HttpServletResponse，每次请求创建不同的对象</li>
<li>一个会话对应一个HttpSession，可包含用户的多个请求</li>
</ol>
<h1>各接口的生命周期？</h1>
<h2 id="servlet-httpservlet">Servlet/HttpServlet</h2>
<ol>
<li>启动时默认不会被实例化（除非配置load-up-startup）</li>
<li>用户访问地址</li>
<li>Web容器解析出对应uri，在容器上下文寻找对应的servlet</li>
<li>找到则调用其service方法</li>
<li>没找到则通过web.xml文件的配置获取完整类型，通过反射实例化</li>
<li>实例化时会执行无参构造方法</li>
<li>传入ServletConfig到init方法</li>
<li>最后调用service方法</li>
<li>销毁：web容器关闭、webapp重新部署、长时间无访问时，则调用destroy()做销毁前的准备</li>
</ol>
<h2 id="servletcontext">ServletContext</h2>
<p>解析web.xml时创建，服务启动时被创建，关闭时销毁。</p>
<h2 id="httpservletrequest-httpservletresponse">HttpServletRequest HttpServletResponse</h2>
<p>一次请求对应一个对象，完成请求则销毁</p>
<h1>我该选择哪个Servlet类去实现？</h1>
<p>HttpServlet。Servlet接口定义了基本方法，GenericServlet是实现了部分方法的抽象类，查看源码可知：</p>
<ol>
<li>实现init(ServletConfig config)，保存了config的引用，并设计一个空的init()供重写</li>
<li>实现service(ServletRequest request,ServletResponse response)，提供service(HttpServletRequest request, HttpServletResponse response)供重写，避免每次进行转型调用</li>
</ol>
<p>HttpServlet是继承GenericServlet的抽象方法，提供了HTTP的更多实现，包括</p>
<ol>
<li>在service方法中解析HTTP请求方式，分发GET到doGet，分发POST到doPost。</li>
<li>提供doXX的默认实现，发送405/400的错误，表示不支持的请求方式。子类需要重写这些方法去支持（巧妙！）</li>
<li>doGet方法调用前，进行了缓存检查，当未过期时返回304 not modify 表示资源未更改</li>
</ol>
<h1>Servlet GenericServlet HttpServlet  体现了什么设计模式？有什么好处？</h1>
<p>模板方法。HttpServlet是一个模板类，实现了核心算法骨架，doGet doPost 具体实现步骤要在子类中完成。</p>
<p>特点：doXX，doYY</p>
<p>作用：</p>
<ul>
<li>核心算法保护</li>
<li>核心算法复用</li>
<li>不改变算法前提下重新定义算法步骤的具体实现</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/posts/2019/01/14/DonkeyCar总结/">DonkeyCar总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-14</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/树莓派/">树莓派</a></span><div class="content"><h1>更新</h1>
<p>这篇文章是我从简书上搬运的，图片都挂掉了。请直接访问原文<a href="https://www.jianshu.com/p/9cdbe3eabac9" target="_blank" rel="noopener">https://www.jianshu.com/p/9cdbe3eabac9</a></p>
<p>考完试，终于有时间把这个学期初的坑填上了。还有几位朋友专门关注了我想知道最新的进展，很抱歉啊很久没有消息，也没有什么大进展，下面就说说目前做了的事情和效果。</p>
<!-- ![DonkeyCar俯视图](https://upload-images.jianshu.io/upload_images/10215367-ae056cd767caa94d.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240) -->
<h1>硬件组装</h1>
<ol>
<li>由于3D打印比较贵，就让队友做了一个简易的车架，把必要的设备上去了，不够美观，但是够用了。</li>
</ol>
<!-- ![DonkeyCar正视图](https://upload-images.jianshu.io/upload_images/10215367-c513dfd15e9cdc11.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240) -->
<h1>场地</h1>
<p>由于没有比较好的地方，而且学校智能车的赛道这学期还没有开放。按照slack上Donkeycar网友给出的图纸，临时画了些线在纸上，可能是场地的原因，场地小不够开放，导致效果不好。基本都在转圈，不是按线行驶。</p>
<!-- ![赛道设计图](https://upload-images.jianshu.io/upload_images/10215367-7836cd0a08d75cab.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240) -->
<!-- ![场地图](https://upload-images.jianshu.io/upload_images/10215367-03a09800fe469249.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1240) -->
<h1>训练过程</h1>
<p>很难操作，加上WIFI延迟波动，命令不能及时调整，导致一开始基本无法获得正确的数据。后来用网线直接连接勉强解决，（这个机器学习真费人力）<br>
近一万张图片，在没有GPU加速的电脑上训练很慢，用了一个多小时。而在GPU的电脑上用十多分钟就解决了。</p>
<h1>最终效果</h1>
<ol>
<li>油门没有输出，找不出原因，只有角度的输出。最后调成只有角度，手动控制油门。</li>
<li>在转弯的地方一直在转圈，不会左转出弯，应该是场地左边黑色的边界给识别进去了，加大了权重，到左转时不足？这里我还有视频，但是好像上传有点麻烦，等我处理后再上传。</li>
<li>训练用的一个方向，但是测试另一个方向时则完全没有效果，估计也是上一个原因吧。</li>
<li>树莓派只能利用CPU来计算，测试的时候CPU占用有75%，就是3个核已经占满了，性能不是很好。</li>
</ol>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2020 By whllhw</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>